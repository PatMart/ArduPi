/**
 * File generated by the ThingML IDE
 * /!\Do not edit this file/!\
 * In case of a bug in the generated code,
 * please submit an issue on our GitHub
 **/

package org.thingml.generated
import org.thingml.generated._
import org.sintef.smac._
import scala.annotation.elidable
import scala.annotation.elidable._
import org.thingml.utils.comm.SerializableTypes._
object Logger {
@elidable(MINIMUM)def debug(s : String) {println("DEBUG:" + s)}
@elidable(INFO)def info(s : String) {println("INFO:" + s)}
@elidable(WARNING)def warning(s : String) {println("WARNING:" + s)}
@elidable(SEVERE)def error(s : String) {println("ERROR:" + s)}
@elidable(MAXIMUM)def severe(s : String) {println("KERNEL PANIC:" + s)}
}
// Definition of Enumeration  PinMode
object PinMode_ENUM extends Enumeration {
	type PinMode_ENUM = Byte
val PINMODE_INPUT : Byte = 0
val PINMODE_OUTPUT : Byte = 1
}
// Definition of Enumeration  DigitalPin
object DigitalPin_ENUM extends Enumeration {
	type DigitalPin_ENUM = Byte
val DIGITALPIN_PIN_0 : Byte = 0
val DIGITALPIN_PIN_1 : Byte = 1
val DIGITALPIN_PIN_2 : Byte = 2
val DIGITALPIN_PIN_3 : Byte = 3
val DIGITALPIN_PIN_4 : Byte = 4
val DIGITALPIN_PIN_5 : Byte = 5
val DIGITALPIN_PIN_6 : Byte = 6
val DIGITALPIN_PIN_7 : Byte = 7
val DIGITALPIN_PIN_8 : Byte = 8
val DIGITALPIN_PIN_9 : Byte = 9
val DIGITALPIN_PIN_10 : Byte = 10
val DIGITALPIN_PIN_11 : Byte = 11
val DIGITALPIN_PIN_12 : Byte = 12
val DIGITALPIN_PIN_13 : Byte = 13
val DIGITALPIN_A_0 : Byte = 14
val DIGITALPIN_A_1 : Byte = 15
val DIGITALPIN_A_2 : Byte = 16
val DIGITALPIN_A_3 : Byte = 17
val DIGITALPIN_A_4 : Byte = 18
val DIGITALPIN_A_5 : Byte = 19
}
// Definition of Enumeration  PWMPin
object PWMPin_ENUM extends Enumeration {
	type PWMPin_ENUM = Byte
val PWMPIN_PWM_PIN_3 : Byte = 3
val PWMPIN_PWM_PIN_5 : Byte = 5
val PWMPIN_PWM_PIN_6 : Byte = 6
val PWMPIN_PWM_PIN_9 : Byte = 9
val PWMPIN_PWM_PIN_10 : Byte = 10
val PWMPIN_PWM_PIN_11 : Byte = 11
}
// Definition of Enumeration  AnalogPin
object AnalogPin_ENUM extends Enumeration {
	type AnalogPin_ENUM = Byte
val ANALOGPIN_A_0 : Byte = 14
val ANALOGPIN_A_1 : Byte = 15
val ANALOGPIN_A_2 : Byte = 16
val ANALOGPIN_A_3 : Byte = 17
val ANALOGPIN_A_4 : Byte = 18
val ANALOGPIN_A_5 : Byte = 19
}
// Definition of Enumeration  AnalogReference
object AnalogReference_ENUM extends Enumeration {
	type AnalogReference_ENUM = Byte
val ANALOGREFERENCE_DEFAULT : Byte = 1
val ANALOGREFERENCE_INTERNAL : Byte = 3
val ANALOGREFERENCE_EXTERNAL : Byte = 0
}
// Definition of Enumeration  InterruptPin
object InterruptPin_ENUM extends Enumeration {
	type InterruptPin_ENUM = Byte
val INTERRUPTPIN_PIN_2_INT0 : Byte = 0
val INTERRUPTPIN_PIN_3_INT1 : Byte = 1
}
// Definition of Enumeration  InterruptTrigger
object InterruptTrigger_ENUM extends Enumeration {
	type InterruptTrigger_ENUM = Byte
val INTERRUPTTRIGGER_CHANGE : Byte = 1
val INTERRUPTTRIGGER_RISING : Byte = 3
val INTERRUPTTRIGGER_FALLING : Byte = 2
val INTERRUPTTRIGGER_LOW : Byte = 0
}
// Definition of Enumeration  DigitalState
object DigitalState_ENUM extends Enumeration {
	type DigitalState_ENUM = Byte
val DIGITALSTATE_LOW : Byte = 0
val DIGITALSTATE_HIGH : Byte = 1
}
object Read_temperature{ def getName = "read_temperature" }
case class Read_temperature(override val name : String = Read_temperature.getName) extends Event(name)/* with java.io.Serializable*/
object No_tone{ def getName = "no_tone" }
case class No_tone(pin : Byte, override val name : String = No_tone.getName) extends Event(name)/* with java.io.Serializable*/
object Light_value{ def getName = "light_value" }
case class Light_value(`val` : Int, override val name : String = Light_value.getName) extends Event(name)/* with java.io.Serializable*/
object Digital_input_value{ def getName = "digital_input_value" }
case class Digital_input_value(value : Byte, override val name : String = Digital_input_value.getName) extends Event(name)/* with java.io.Serializable*/
object Read_digital_input{ def getName = "read_digital_input" }
case class Read_digital_input(override val name : String = Read_digital_input.getName) extends Event(name)/* with java.io.Serializable*/
object Led_off{ def getName = "led_off" }
case class Led_off(override val name : String = Led_off.getName) extends Event(name)/* with java.io.Serializable*/
object Eeprom_write_ack{ def getName = "eeprom_write_ack" }
case class Eeprom_write_ack(override val name : String = Eeprom_write_ack.getName) extends Event(name)/* with java.io.Serializable*/
object Led_on{ def getName = "led_on" }
case class Led_on(override val name : String = Led_on.getName) extends Event(name)/* with java.io.Serializable*/
object Analog_reference{ def getName = "analog_reference" }
case class Analog_reference(`type` : Byte, override val name : String = Analog_reference.getName) extends Event(name)/* with java.io.Serializable*/
object Interrupt_notification{ def getName = "interrupt_notification" }
case class Interrupt_notification(interrupt : Byte, override val name : String = Interrupt_notification.getName) extends Event(name)/* with java.io.Serializable*/
object Eeprom_sync_write{ def getName = "eeprom_sync_write" }
case class Eeprom_sync_write(address : Int, value : Int, override val name : String = Eeprom_sync_write.getName) extends Event(name)/* with java.io.Serializable*/
object Setup{ def getName = "setup" }
case class Setup(override val name : String = Setup.getName) extends Event(name)/* with java.io.Serializable*/
object Digital_read{ def getName = "digital_read" }
case class Digital_read(pin : Byte, override val name : String = Digital_read.getName) extends Event(name)/* with java.io.Serializable*/
object Ping{ def getName = "ping" }
case class Ping(override val name : String = Ping.getName) extends Event(name)/* with java.io.Serializable*/
object Analog_read_result{ def getName = "analog_read_result" }
case class Analog_read_result(pin : Byte, value : Int, override val name : String = Analog_read_result.getName) extends Event(name)/* with java.io.Serializable*/
object Detach_interrupt{ def getName = "detach_interrupt" }
case class Detach_interrupt(interrupt : Byte, override val name : String = Detach_interrupt.getName) extends Event(name)/* with java.io.Serializable*/
object InitDisplay{ def getName = "initDisplay" }
case class InitDisplay(id : Int, title : String, unit : String, initValue : Int, minValue : Int, maxValue : Int, override val name : String = InitDisplay.getName) extends Event(name)/* with java.io.Serializable*/
object Pong{ def getName = "pong" }
case class Pong(override val name : String = Pong.getName) extends Event(name)/* with java.io.Serializable*/
object Temperature_value{ def getName = "temperature_value" }
case class Temperature_value(`val` : Int, override val name : String = Temperature_value.getName) extends Event(name)/* with java.io.Serializable*/
object Attach_interrupt{ def getName = "attach_interrupt" }
case class Attach_interrupt(interrupt : Byte, mode : Byte, override val name : String = Attach_interrupt.getName) extends Event(name)/* with java.io.Serializable*/
object Read_analog_input{ def getName = "read_analog_input" }
case class Read_analog_input(override val name : String = Read_analog_input.getName) extends Event(name)/* with java.io.Serializable*/
object Timer_cancel{ def getName = "timer_cancel" }
case class Timer_cancel(override val name : String = Timer_cancel.getName) extends Event(name)/* with java.io.Serializable*/
object Led_toggle{ def getName = "led_toggle" }
case class Led_toggle(override val name : String = Led_toggle.getName) extends Event(name)/* with java.io.Serializable*/
object RefreshDisplay{ def getName = "refreshDisplay" }
case class RefreshDisplay(id : Int, value : Int, override val name : String = RefreshDisplay.getName) extends Event(name)/* with java.io.Serializable*/
object Poll{ def getName = "poll" }
case class Poll(override val name : String = Poll.getName) extends Event(name)/* with java.io.Serializable*/
object Analog_input_value{ def getName = "analog_input_value" }
case class Analog_input_value(value : Int, override val name : String = Analog_input_value.getName) extends Event(name)/* with java.io.Serializable*/
object Digital_write{ def getName = "digital_write" }
case class Digital_write(pin : Byte, value : Byte, override val name : String = Digital_write.getName) extends Event(name)/* with java.io.Serializable*/
object Light{ def getName = "light" }
case class Light(light : Int, override val name : String = Light.getName) extends Event(name)/* with java.io.Serializable*/
object Release{ def getName = "release" }
case class Release(override val name : String = Release.getName) extends Event(name)/* with java.io.Serializable*/
object Temperature{ def getName = "temperature" }
case class Temperature(temp : Int, override val name : String = Temperature.getName) extends Event(name)/* with java.io.Serializable*/
object Analog_read{ def getName = "analog_read" }
case class Analog_read(pin : Byte, override val name : String = Analog_read.getName) extends Event(name)/* with java.io.Serializable*/
object SetDisplay{ def getName = "setDisplay" }
case class SetDisplay(id : Int, override val name : String = SetDisplay.getName) extends Event(name)/* with java.io.Serializable*/
object Press{ def getName = "press" }
case class Press(override val name : String = Press.getName) extends Event(name)/* with java.io.Serializable*/
object Timer_timeout{ def getName = "timer_timeout" }
case class Timer_timeout(override val name : String = Timer_timeout.getName) extends Event(name)/* with java.io.Serializable*/
object Update{ def getName = "update" }
case class Update(override val name : String = Update.getName) extends Event(name)/* with java.io.Serializable*/
object Eeprom_write{ def getName = "eeprom_write" }
case class Eeprom_write(address : Int, value : Int, override val name : String = Eeprom_write.getName) extends Event(name)/* with java.io.Serializable*/
object CurrentDisplay{ def getName = "currentDisplay" }
case class CurrentDisplay(id : Int, override val name : String = CurrentDisplay.getName) extends Event(name)/* with java.io.Serializable*/
object Eeprom_read{ def getName = "eeprom_read" }
case class Eeprom_read(address : Int, override val name : String = Eeprom_read.getName) extends Event(name)/* with java.io.Serializable*/
object ChangeDisplay{ def getName = "changeDisplay" }
case class ChangeDisplay(override val name : String = ChangeDisplay.getName) extends Event(name)/* with java.io.Serializable*/
object Tone{ def getName = "tone" }
case class Tone(pin : Byte, frequency : Int, duration : Int, override val name : String = Tone.getName) extends Event(name)/* with java.io.Serializable*/
object Set_digital_output{ def getName = "set_digital_output" }
case class Set_digital_output(value : Byte, override val name : String = Set_digital_output.getName) extends Event(name)/* with java.io.Serializable*/
object Pin_mode{ def getName = "pin_mode" }
case class Pin_mode(pin : Byte, mode : Byte, override val name : String = Pin_mode.getName) extends Event(name)/* with java.io.Serializable*/
object Digital_read_result{ def getName = "digital_read_result" }
case class Digital_read_result(pin : Byte, value : Byte, override val name : String = Digital_read_result.getName) extends Event(name)/* with java.io.Serializable*/
object Timer_start{ def getName = "timer_start" }
case class Timer_start(delay : Int, override val name : String = Timer_start.getName) extends Event(name)/* with java.io.Serializable*/
object Eeprom_value{ def getName = "eeprom_value" }
case class Eeprom_value(value : Int, override val name : String = Eeprom_value.getName) extends Event(name)/* with java.io.Serializable*/
object Analog_write{ def getName = "analog_write" }
case class Analog_write(pin : Byte, value : Int, override val name : String = Analog_write.getName) extends Event(name)/* with java.io.Serializable*/
object Read_light{ def getName = "read_light" }
case class Read_light(override val name : String = Read_light.getName) extends Event(name)/* with java.io.Serializable*/

/**
 * Definitions for type : SimulatorArduino
 **/
class SimulatorArduino(private var _SimulatorArduino_temp_var : Int, private var _SimulatorArduino_light_var : Int, val SimulatorArduino_tempDisplay_var : Int, val SimulatorArduino_lightDisplay_var : Int) extends Component {

//Synchronized accessors of temp:Int
def SimulatorArduino_temp_var:Int = {synchronized{return _SimulatorArduino_temp_var}}
def SimulatorArduino_temp_var_=(newValue : Int) { synchronized{ _SimulatorArduino_temp_var = newValue}}

//Synchronized accessors of light:Int
def SimulatorArduino_light_var:Int = {synchronized{return _SimulatorArduino_light_var}}
def SimulatorArduino_light_var_=(newValue : Int) { synchronized{ _SimulatorArduino_light_var = newValue}}

//Companion object
object SimulatorArduino{
object DisplayPort{
def getName = "Display"
object in {
}
object out {
val initDisplay_o = InitDisplay.getName
val refreshDisplay_o = RefreshDisplay.getName
val setDisplay_o = SetDisplay.getName
}
}

object RemoteControlPort{
def getName = "RemoteControl"
object in {
val changeDisplay_i = ChangeDisplay.getName
}
object out {
val temperature_o = Temperature.getName
val light_o = Light.getName
}
}

object TemperatureSensorPort{
def getName = "TemperatureSensor"
object in {
val temperature_value_i = Temperature_value.getName
}
object out {
val read_temperature_o = Read_temperature.getName
}
}

object LightSensorPort{
def getName = "LightSensor"
object in {
val light_value_i = Light_value.getName
}
object out {
val read_light_o = Read_light.getName
}
}

object LedPort{
def getName = "Led"
object in {
}
object out {
val led_on_o = Led_on.getName
val led_off_o = Led_off.getName
val led_toggle_o = Led_toggle.getName
}
}

object ButtonPort{
def getName = "Button"
object in {
val press_i = Press.getName
val release_i = Release.getName
}
object out {
}
}

}

new Port(SimulatorArduino.DisplayPort.getName, List(), List(SimulatorArduino.DisplayPort.out.initDisplay_o, SimulatorArduino.DisplayPort.out.refreshDisplay_o, SimulatorArduino.DisplayPort.out.setDisplay_o), this).start
new Port(SimulatorArduino.RemoteControlPort.getName, List(SimulatorArduino.RemoteControlPort.in.changeDisplay_i), List(SimulatorArduino.RemoteControlPort.out.temperature_o, SimulatorArduino.RemoteControlPort.out.light_o), this).start
new Port(SimulatorArduino.TemperatureSensorPort.getName, List(SimulatorArduino.TemperatureSensorPort.in.temperature_value_i), List(SimulatorArduino.TemperatureSensorPort.out.read_temperature_o), this).start
new Port(SimulatorArduino.LightSensorPort.getName, List(SimulatorArduino.LightSensorPort.in.light_value_i), List(SimulatorArduino.LightSensorPort.out.read_light_o), this).start
new Port(SimulatorArduino.LedPort.getName, List(), List(SimulatorArduino.LedPort.out.led_on_o, SimulatorArduino.LedPort.out.led_off_o, SimulatorArduino.LedPort.out.led_toggle_o), this).start
new Port(SimulatorArduino.ButtonPort.getName, List(SimulatorArduino.ButtonPort.in.press_i, SimulatorArduino.ButtonPort.in.release_i), List(), this).start
this.behavior ++= List(new SensorsDisplayImplStateMachine(false, this).getBehavior)
case class SensorsDisplayImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("SensorsDisplayImpl.onEntry")
handler.getPort("Display") match{
case Some(p) => p.send(new InitDisplay(SimulatorArduino_tempDisplay_var, "Temperature", "C", 25, 15, 40))
case None => Logger.warning("no port Display You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
handler.getPort("Display") match{
case Some(p) => p.send(new InitDisplay(SimulatorArduino_lightDisplay_var, "Light", "", 0, 0, 1023))
case None => Logger.warning("no port Display You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

override def onExit() = {
Logger.debug("SensorsDisplayImpl.onExit")
//No exit action defined for this state
}

new InternalTransition(getBehavior, new InternalTransition_SensorsDisplayImpl_25366887(), List((SimulatorArduino.TemperatureSensorPort.getName, SimulatorArduino.TemperatureSensorPort.in.temperature_value_i)))
new InternalTransition(getBehavior, new InternalTransition_SensorsDisplayImpl_31933850(), List((SimulatorArduino.LightSensorPort.getName, SimulatorArduino.LightSensorPort.in.light_value_i)))
case class InternalTransition_SensorsDisplayImpl_25366887 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_SensorsDisplayImpl_25366887.executeActions")
Logger.info((("temperature received: " + getEvent(SimulatorArduino.TemperatureSensorPort.in.temperature_value_i, SimulatorArduino.TemperatureSensorPort.getName).get.asInstanceOf[Temperature_value].`val`)).toString)
handler.getPort("Display") match{
case Some(p) => p.send(new RefreshDisplay(SimulatorArduino_tempDisplay_var, getEvent(SimulatorArduino.TemperatureSensorPort.in.temperature_value_i, SimulatorArduino.TemperatureSensorPort.getName).get.asInstanceOf[Temperature_value].`val`))
case None => Logger.warning("no port Display You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
SimulatorArduino_temp_var = (getEvent(SimulatorArduino.TemperatureSensorPort.in.temperature_value_i, SimulatorArduino.TemperatureSensorPort.getName).get.asInstanceOf[Temperature_value].`val`).asInstanceOf[Int]
}

}
case class InternalTransition_SensorsDisplayImpl_31933850 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_SensorsDisplayImpl_31933850.executeActions")
Logger.info((("light received: " + getEvent(SimulatorArduino.LightSensorPort.in.light_value_i, SimulatorArduino.LightSensorPort.getName).get.asInstanceOf[Light_value].`val`)).toString)
handler.getPort("Display") match{
case Some(p) => p.send(new RefreshDisplay(SimulatorArduino_lightDisplay_var, getEvent(SimulatorArduino.LightSensorPort.in.light_value_i, SimulatorArduino.LightSensorPort.getName).get.asInstanceOf[Light_value].`val`))
case None => Logger.warning("no port Display You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
SimulatorArduino_light_var = (getEvent(SimulatorArduino.LightSensorPort.in.light_value_i, SimulatorArduino.LightSensorPort.getName).get.asInstanceOf[Light_value].`val`).asInstanceOf[Int]
}

}
//create sub-states
private val _Temp_state = TempState()
val Temp_state = new State(_Temp_state, root)
_Temp_state.init
parent.addSubState(Temp_state)
case class TempState extends StateAction {
override def onEntry() = {
Logger.debug("Temp.onEntry")
handler.getPort("Display") match{
case Some(p) => p.send(new SetDisplay(SimulatorArduino_tempDisplay_var))
case None => Logger.warning("no port Display You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

override def onExit() = {
Logger.debug("Temp.onExit")
handler.getPort("Led") match{
case Some(p) => p.send(new Led_toggle())
case None => Logger.warning("no port Led You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
handler.getPort("RemoteControl") match{
case Some(p) => p.send(new Temperature(SimulatorArduino_temp_var))
case None => Logger.warning("no port RemoteControl You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
handler.getPort("Led") match{
case Some(p) => p.send(new Led_toggle())
case None => Logger.warning("no port Led You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

def init {
}

}

private val _Light_state = LightState()
val Light_state = new State(_Light_state, root)
_Light_state.init
parent.addSubState(Light_state)
case class LightState extends StateAction {
override def onEntry() = {
Logger.debug("Light.onEntry")
handler.getPort("Display") match{
case Some(p) => p.send(new SetDisplay(SimulatorArduino_lightDisplay_var))
case None => Logger.warning("no port Display You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

override def onExit() = {
Logger.debug("Light.onExit")
handler.getPort("Led") match{
case Some(p) => p.send(new Led_toggle())
case None => Logger.warning("no port Led You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
handler.getPort("RemoteControl") match{
case Some(p) => p.send(new Light(SimulatorArduino_light_var))
case None => Logger.warning("no port RemoteControl You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
handler.getPort("Led") match{
case Some(p) => p.send(new Led_toggle())
case None => Logger.warning("no port Led You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

def init {
}

}

parent.setInitial(Temp_state)

//create transitions among sub-states
val t_Temp2Light_13533864 = new Transition(Temp_state, Light_state, new TransitionTemp2Light_13533864(), List((SimulatorArduino.ButtonPort.getName, SimulatorArduino.ButtonPort.in.release_i), (SimulatorArduino.RemoteControlPort.getName, SimulatorArduino.RemoteControlPort.in.changeDisplay_i)))
parent.addTransition(t_Temp2Light_13533864)
val t_Light2Temp_22878365 = new Transition(Light_state, Temp_state, new TransitionLight2Temp_22878365(), List((SimulatorArduino.ButtonPort.getName, SimulatorArduino.ButtonPort.in.release_i), (SimulatorArduino.RemoteControlPort.getName, SimulatorArduino.RemoteControlPort.in.changeDisplay_i)))
parent.addTransition(t_Light2Temp_22878365)
case class TransitionTemp2Light_13533864 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_Temp2Light_13533864.executeActions")
//No action defined for this transition
}

}
case class TransitionLight2Temp_22878365 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_Light2Temp_22878365.executeActions")
//No action defined for this transition
}

}
}
}

/**
 * Definitions for type : TemperatureSensorScala
 **/
class TemperatureSensorScala() extends Component {

//Companion object
object TemperatureSensorScala{
object TemperatureSensorPort{
def getName = "TemperatureSensor"
object in {
val read_temperature_i = Read_temperature.getName
}
object out {
val temperature_value_o = Temperature_value.getName
}
}

}

new Port(TemperatureSensorScala.TemperatureSensorPort.getName, List(TemperatureSensorScala.TemperatureSensorPort.in.read_temperature_i), List(TemperatureSensorScala.TemperatureSensorPort.out.temperature_value_o), this).start
}

/**
 * Definitions for type : LcdScreenScala
 **/
class LcdScreenScala() extends Component {

//Companion object
object LcdScreenScala{
object DisplayPort{
def getName = "Display"
object in {
val initDisplay_i = InitDisplay.getName
val refreshDisplay_i = RefreshDisplay.getName
val setDisplay_i = SetDisplay.getName
}
object out {
val currentDisplay_o = CurrentDisplay.getName
}
}

}

new Port(LcdScreenScala.DisplayPort.getName, List(LcdScreenScala.DisplayPort.in.initDisplay_i, LcdScreenScala.DisplayPort.in.refreshDisplay_i, LcdScreenScala.DisplayPort.in.setDisplay_i), List(LcdScreenScala.DisplayPort.out.currentDisplay_o), this).start
}

/**
 * Definitions for type : ButtonScala
 **/
class ButtonScala(private var _ButtonScala_lastValue_var : Boolean, val Brick_device_var : org.thingml.devices.Device) extends Component with org.thingml.devices.Observer[Boolean]{

//Synchronized accessors of lastValue:Boolean
def ButtonScala_lastValue_var:Boolean = {synchronized{return _ButtonScala_lastValue_var}}
def ButtonScala_lastValue_var_=(newValue : Boolean) { synchronized{ _ButtonScala_lastValue_var = newValue}}

//Companion object
object ButtonScala{
object SensorMockUpPort{
def getName = "SensorMockUp"
object in {
}
object out {
val update_o = Update.getName
}
}

object SensorPort{
def getName = "Sensor"
object in {
val update_i = Update.getName
}
object out {
}
}

object ButtonPort{
def getName = "Button"
object in {
}
object out {
val press_o = Press.getName
val release_o = Release.getName
}
}

object DigitalInputPort{
def getName = "DigitalInput"
object in {
val digital_input_value_i = Digital_input_value.getName
}
object out {
}
}

}

new Port(ButtonScala.SensorMockUpPort.getName, List(), List(ButtonScala.SensorMockUpPort.out.update_o), this).start
new Port(ButtonScala.SensorPort.getName, List(ButtonScala.SensorPort.in.update_i), List(), this).start
new Port(ButtonScala.ButtonPort.getName, List(), List(ButtonScala.ButtonPort.out.press_o, ButtonScala.ButtonPort.out.release_o), this).start
new Port(ButtonScala.DigitalInputPort.getName, List(ButtonScala.DigitalInputPort.in.digital_input_value_i), List(), this).start
override def newValue(ButtonScala_newValue_v_var : Boolean) : Unit = {
Logger.debug("Executing newValue ...")
val handler = this
ButtonScala_lastValue_var = (ButtonScala_newValue_v_var).asInstanceOf[Boolean]
handler.getPort("SensorMockUp") match{
case Some(p) => p.send(new Update())
case None => Logger.warning("no port SensorMockUp You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}
def register() : Unit = {
Logger.debug("Executing register ...")
val handler = this
Brick_device_var.asInstanceOf[org.thingml.devices.Observable[Boolean]].register(this)
}
this.behavior ++= List(new BehaviorStateMachine(false, this).getBehavior)
this.behavior ++= List(new ButtonImplStateMachine(false, this).getBehavior)
case class BehaviorStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("behavior.onEntry")
register()
}

override def onExit() = {
Logger.debug("behavior.onExit")
//No exit action defined for this state
}

new InternalTransition(getBehavior, new InternalTransition_behavior_13721184(), List((ButtonScala.SensorPort.getName, ButtonScala.SensorPort.in.update_i)))
case class InternalTransition_behavior_13721184 extends InternalTransitionAction {
override def executeActions() = {
Logger.debug("t_self_behavior_13721184.executeActions")
if(ButtonScala_lastValue_var) {
Logger.info((("press")).toString)
handler.getPort("Button") match{
case Some(p) => p.send(new Press())
case None => Logger.warning("no port Button You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}

}
if( !(ButtonScala_lastValue_var)) {
Logger.info((("release")).toString)
handler.getPort("Button") match{
case Some(p) => p.send(new Release())
case None => Logger.warning("no port Button You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}

}
}

}
//create sub-states
private val _Ready_state = ReadyState()
val Ready_state = new State(_Ready_state, root)
_Ready_state.init
parent.addSubState(Ready_state)
case class ReadyState extends StateAction {
override def onEntry() = {
Logger.debug("Ready.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("Ready.onExit")
//No exit action defined for this state
}

def init {
}

}

parent.setInitial(Ready_state)

//create transitions among sub-states
}
case class ButtonImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("ButtonImpl.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("ButtonImpl.onExit")
//No exit action defined for this state
}

//create sub-states
private val _Running_state = RunningState()
val Running_state = new State(_Running_state, root)
_Running_state.init
parent.addSubState(Running_state)
case class RunningState extends StateAction {
override def onEntry() = {
Logger.debug("Running.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("Running.onExit")
//No exit action defined for this state
}

def init {
new InternalTransition(getBehavior, new InternalTransition_Running_10204077(), List((ButtonScala.DigitalInputPort.getName, ButtonScala.DigitalInputPort.in.digital_input_value_i)))
new InternalTransition(getBehavior, new InternalTransition_Running_8081673(), List((ButtonScala.DigitalInputPort.getName, ButtonScala.DigitalInputPort.in.digital_input_value_i)))
}

case class InternalTransition_Running_10204077 extends InternalTransitionAction {
override def checkGuard() : Boolean = {
getEvent(ButtonScala.DigitalInputPort.in.digital_input_value_i, ButtonScala.DigitalInputPort.getName).get.asInstanceOf[Digital_input_value].value == DigitalState_ENUM.DIGITALSTATE_HIGH
}
override def executeActions() = {
Logger.debug("t_self_Running_10204077.executeActions")
handler.getPort("Button") match{
case Some(p) => p.send(new Press())
case None => Logger.warning("no port Button You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

}
case class InternalTransition_Running_8081673 extends InternalTransitionAction {
override def checkGuard() : Boolean = {
getEvent(ButtonScala.DigitalInputPort.in.digital_input_value_i, ButtonScala.DigitalInputPort.getName).get.asInstanceOf[Digital_input_value].value == DigitalState_ENUM.DIGITALSTATE_LOW
}
override def executeActions() = {
Logger.debug("t_self_Running_8081673.executeActions")
handler.getPort("Button") match{
case Some(p) => p.send(new Release())
case None => Logger.warning("no port Button You may consider revising your ThingML model. Or contact the development team if you think it is a bug.")
}
}

}
}

parent.setInitial(Running_state)

//create transitions among sub-states
}
}

/**
 * Definitions for type : LedScala
 **/
class LedScala(val Brick_device_var : org.thingml.devices.Device) extends Component {

//Companion object
object LedScala{
object LedPort{
def getName = "Led"
object in {
val led_on_i = Led_on.getName
val led_off_i = Led_off.getName
val led_toggle_i = Led_toggle.getName
}
object out {
}
}

}

new Port(LedScala.LedPort.getName, List(LedScala.LedPort.in.led_on_i, LedScala.LedPort.in.led_off_i, LedScala.LedPort.in.led_toggle_i), List(), this).start
this.behavior ++= List(new LedImplStateMachine(false, this).getBehavior)
case class LedImplStateMachine(keepHistory : Boolean, root : Component) extends StateAction {
override def getBehavior = parent
val parent : StateMachine = new StateMachine(this, keepHistory, root)
override def onEntry() = {
Logger.debug("LedImpl.onEntry")
//No entry action defined for this state
}

override def onExit() = {
Logger.debug("LedImpl.onExit")
//No exit action defined for this state
}

//create sub-states
private val _LedOff_state = LedOffState()
val LedOff_state = new State(_LedOff_state, root)
_LedOff_state.init
parent.addSubState(LedOff_state)
case class LedOffState extends StateAction {
override def onEntry() = {
Logger.debug("LedOff.onEntry")
Brick_device_var.asInstanceOf[org.thingml.devices.LedDemo].off()
}

override def onExit() = {
Logger.debug("LedOff.onExit")
//No exit action defined for this state
}

def init {
}

}

private val _LedOn_state = LedOnState()
val LedOn_state = new State(_LedOn_state, root)
_LedOn_state.init
parent.addSubState(LedOn_state)
case class LedOnState extends StateAction {
override def onEntry() = {
Logger.debug("LedOn.onEntry")
Brick_device_var.asInstanceOf[org.thingml.devices.LedDemo].on()
}

override def onExit() = {
Logger.debug("LedOn.onExit")
//No exit action defined for this state
}

def init {
}

}

parent.setInitial(LedOff_state)

//create transitions among sub-states
val t_LedOff2LedOn_31361709 = new Transition(LedOff_state, LedOn_state, new TransitionLedOff2LedOn_31361709(), List((LedScala.LedPort.getName, LedScala.LedPort.in.led_on_i)))
parent.addTransition(t_LedOff2LedOn_31361709)
val t_LedOff2LedOn_30584630 = new Transition(LedOff_state, LedOn_state, new TransitionLedOff2LedOn_30584630(), List((LedScala.LedPort.getName, LedScala.LedPort.in.led_toggle_i)))
parent.addTransition(t_LedOff2LedOn_30584630)
val t_LedOn2LedOff_28010999 = new Transition(LedOn_state, LedOff_state, new TransitionLedOn2LedOff_28010999(), List((LedScala.LedPort.getName, LedScala.LedPort.in.led_off_i)))
parent.addTransition(t_LedOn2LedOff_28010999)
val t_LedOn2LedOff_10874956 = new Transition(LedOn_state, LedOff_state, new TransitionLedOn2LedOff_10874956(), List((LedScala.LedPort.getName, LedScala.LedPort.in.led_toggle_i)))
parent.addTransition(t_LedOn2LedOff_10874956)
case class TransitionLedOff2LedOn_31361709 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_LedOff2LedOn_31361709.executeActions")
//No action defined for this transition
}

}
case class TransitionLedOff2LedOn_30584630 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_LedOff2LedOn_30584630.executeActions")
Logger.info((("toggling (fast!!!)")).toString)
}

}
case class TransitionLedOn2LedOff_28010999 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_LedOn2LedOff_28010999.executeActions")
//No action defined for this transition
}

}
case class TransitionLedOn2LedOff_10874956 extends TransitionAction {
override def executeActions() = {
Logger.debug("t_LedOn2LedOff_10874956.executeActions")
Logger.info((("toggling (fast!!!)")).toString)
}

}
}
}

/**
 * Definitions for type : LightSensorScala
 **/
class LightSensorScala() extends Component {

//Companion object
object LightSensorScala{
object LightSensorPort{
def getName = "LightSensor"
object in {
val read_light_i = Read_light.getName
}
object out {
val light_value_o = Light_value.getName
}
}

}

new Port(LightSensorScala.LightSensorPort.getName, List(LightSensorScala.LightSensorPort.in.read_light_i), List(LightSensorScala.LightSensorPort.out.light_value_o), this).start
}

/**
 * Definitions for type : WeatherStationRPi
 **/
class WeatherStationRPi() extends Component {

//Companion object
object WeatherStationRPi{
object RemoteControlInPort{
def getName = "RemoteControlIn"
object in {
val temperature_i = Temperature.getName
val light_i = Light.getName
}
object out {
}
}

object RemoteControlOutPort{
def getName = "RemoteControlOut"
object in {
}
object out {
val changeDisplay_o = ChangeDisplay.getName
}
}

}

new Port(WeatherStationRPi.RemoteControlInPort.getName, List(WeatherStationRPi.RemoteControlInPort.in.temperature_i, WeatherStationRPi.RemoteControlInPort.in.light_i), List(), this).start
new Port(WeatherStationRPi.RemoteControlOutPort.getName, List(), List(WeatherStationRPi.RemoteControlOutPort.out.changeDisplay_o), this).start
}

// Initialize instance variables and states

