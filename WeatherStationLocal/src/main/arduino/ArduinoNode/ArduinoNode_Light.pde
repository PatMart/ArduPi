
/***************************************************************************** 
 * File generated from ThingML (Do not edit this file) 
 *****************************************************************************/


/*****************************************************************************
 * Definition of simple types and enumerations
 *****************************************************************************/

// Definition of Enumeration  DigitalState
#define DIGITALSTATE_LOW 0
#define DIGITALSTATE_HIGH 1

// Definition of Enumeration  PinMode
#define PINMODE_INPUT 0
#define PINMODE_OUTPUT 1

// Definition of Enumeration  DigitalPin
#define DIGITALPIN_PIN_0 0
#define DIGITALPIN_PIN_1 1
#define DIGITALPIN_PIN_2 2
#define DIGITALPIN_PIN_3 3
#define DIGITALPIN_PIN_4 4
#define DIGITALPIN_PIN_5 5
#define DIGITALPIN_PIN_6 6
#define DIGITALPIN_PIN_7 7
#define DIGITALPIN_PIN_8 8
#define DIGITALPIN_PIN_9 9
#define DIGITALPIN_PIN_10 10
#define DIGITALPIN_PIN_11 11
#define DIGITALPIN_PIN_12 12
#define DIGITALPIN_PIN_13 13
#define DIGITALPIN_A_0 14
#define DIGITALPIN_A_1 15
#define DIGITALPIN_A_2 16
#define DIGITALPIN_A_3 17
#define DIGITALPIN_A_4 18
#define DIGITALPIN_A_5 19

// Definition of Enumeration  PWMPin
#define PWMPIN_PWM_PIN_3 3
#define PWMPIN_PWM_PIN_5 5
#define PWMPIN_PWM_PIN_6 6
#define PWMPIN_PWM_PIN_9 9
#define PWMPIN_PWM_PIN_10 10
#define PWMPIN_PWM_PIN_11 11

// Definition of Enumeration  AnalogPin
#define ANALOGPIN_A_0 14
#define ANALOGPIN_A_1 15
#define ANALOGPIN_A_2 16
#define ANALOGPIN_A_3 17
#define ANALOGPIN_A_4 18
#define ANALOGPIN_A_5 19

// Definition of Enumeration  AnalogReference
#define ANALOGREFERENCE_DEFAULT 1
#define ANALOGREFERENCE_INTERNAL 3
#define ANALOGREFERENCE_EXTERNAL 0

// Definition of Enumeration  InterruptPin
#define INTERRUPTPIN_PIN_2_INT0 0
#define INTERRUPTPIN_PIN_3_INT1 1

// Definition of Enumeration  InterruptTrigger
#define INTERRUPTTRIGGER_CHANGE 1
#define INTERRUPTTRIGGER_RISING 3
#define INTERRUPTTRIGGER_FALLING 2
#define INTERRUPTTRIGGER_LOW 0

/*****************************************************************************
 * Headers for type : MessageDeserializer
 *****************************************************************************/

// Definition of the instance stuct:
struct MessageDeserializer_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int MessageDeserializer_receive_State;
// Variables for the properties of the instance
uint8_t PacketManager_lengthInteger_var;
uint8_t PacketManager_lengthString_var;
uint8_t PacketManager_lengthUInt16_var;
int PacketManager_MAX_PACKET_SIZE_var;
uint8_t PacketManager_START_BYTE_var;
uint8_t PacketManager_STOP_BYTE_var;
uint8_t PacketManager_ESCAPE_BYTE_var;
int PacketManager_CODE_POSITION_var;
int PacketManager_LENGTH_POSITION_var;
int PacketManager_DATA_POSITION_var;
uint8_t PacketManager_buffer_var[16];
int PacketManager_index_var;
};

// Declaration of prototypes outgoing messages:
void MessageDeserializer_receive_OnEntry(int state, struct MessageDeserializer_Instance *_instance);
void MessageDeserializer_handle_serial_serial_rx(struct MessageDeserializer_Instance *_instance, uint8_t b);
// Declaration of callbacks for incomming messages:
void register_MessageDeserializer_send_RemoteControl_changeDisplay_listener(void (*_listener)(struct MessageDeserializer_Instance*));

// Definition of the states:
#define MESSAGEDESERIALIZER_RECEIVE_STATE 0
#define MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE 1
#define MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE 2
#define MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE 3

/*****************************************************************************
 * Implementation for type : MessageDeserializer
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void MessageDeserializer_receive_OnExit(int state, struct MessageDeserializer_Instance *_instance);
void MessageDeserializer_send_RemoteControl_changeDisplay(struct MessageDeserializer_Instance *_instance);
void f_MessageDeserializer_forward(struct MessageDeserializer_Instance *_instance);
void f_MessageDeserializer_deserializeRemote_changeDisplay(struct MessageDeserializer_Instance *_instance);
int f_MessageDeserializer_deserializeInteger(struct MessageDeserializer_Instance *_instance);
uint16_t f_MessageDeserializer_deserializeUInt16(struct MessageDeserializer_Instance *_instance);
void f_MessageDeserializer_setHeader(struct MessageDeserializer_Instance *_instance, uint8_t code, uint8_t length);
void f_MessageDeserializer_storeByte(struct MessageDeserializer_Instance *_instance, uint8_t b);
uint8_t f_MessageDeserializer_readByte(struct MessageDeserializer_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:
// Definition of function forward
void f_MessageDeserializer_forward(struct MessageDeserializer_Instance *_instance) {
{
_instance->PacketManager_index_var = _instance->PacketManager_DATA_POSITION_var;
uint8_t code = _instance->PacketManager_buffer_var[_instance->PacketManager_CODE_POSITION_var];
if(code == 20) {
f_MessageDeserializer_deserializeRemote_changeDisplay(_instance);
}
}
}

// Definition of function deserializeRemote_changeDisplay
void f_MessageDeserializer_deserializeRemote_changeDisplay(struct MessageDeserializer_Instance *_instance) {
{
MessageDeserializer_send_RemoteControl_changeDisplay(_instance);
}
}

// Definition of function deserializeInteger
int f_MessageDeserializer_deserializeInteger(struct MessageDeserializer_Instance *_instance) {
{
int res = f_MessageDeserializer_readByte(_instance) << 8  + f_MessageDeserializer_readByte(_instance);
return res;
}
}

// Definition of function deserializeUInt16
uint16_t f_MessageDeserializer_deserializeUInt16(struct MessageDeserializer_Instance *_instance) {
{
uint16_t res = f_MessageDeserializer_readByte(_instance) << 8 |  + f_MessageDeserializer_readByte(_instance);
return res;
}
}

// Definition of function setHeader
void f_MessageDeserializer_setHeader(struct MessageDeserializer_Instance *_instance, uint8_t code, uint8_t length) {
{
_instance->PacketManager_index_var = 0;
f_MessageDeserializer_storeByte(_instance, 1);
f_MessageDeserializer_storeByte(_instance, 0);
f_MessageDeserializer_storeByte(_instance, 0);
_instance->PacketManager_CODE_POSITION_var = _instance->PacketManager_index_var;
f_MessageDeserializer_storeByte(_instance, code);
_instance->PacketManager_LENGTH_POSITION_var = _instance->PacketManager_index_var;
f_MessageDeserializer_storeByte(_instance, length);
_instance->PacketManager_DATA_POSITION_var = _instance->PacketManager_index_var;
_instance->PacketManager_index_var = _instance->PacketManager_DATA_POSITION_var;
}
}

// Definition of function storeByte
void f_MessageDeserializer_storeByte(struct MessageDeserializer_Instance *_instance, uint8_t b) {
{
if(_instance->PacketManager_index_var == _instance->PacketManager_MAX_PACKET_SIZE_var) {
// ERROR: ("BUFFER OVERFLOW\n")
}
if(_instance->PacketManager_index_var < _instance->PacketManager_MAX_PACKET_SIZE_var) {
_instance->PacketManager_buffer_var[_instance->PacketManager_index_var] = b;
_instance->PacketManager_index_var = _instance->PacketManager_index_var + 1;
}
}
}

// Definition of function readByte
uint8_t f_MessageDeserializer_readByte(struct MessageDeserializer_Instance *_instance) {
{
uint8_t b;
if(_instance->PacketManager_index_var < _instance->PacketManager_MAX_PACKET_SIZE_var) {
b = _instance->PacketManager_buffer_var[_instance->PacketManager_index_var];
_instance->PacketManager_index_var = _instance->PacketManager_index_var + 1;
}
if(_instance->PacketManager_index_var == _instance->PacketManager_MAX_PACKET_SIZE_var) {
// ERROR: ("BUFFER OVERFLOW: trying to read out of buffer boundaries")
b = _instance->PacketManager_STOP_BYTE_var;
}
return b;
}
}


// On Entry Actions:
void MessageDeserializer_receive_OnEntry(int state, struct MessageDeserializer_Instance *_instance) {
switch(state) {
case MESSAGEDESERIALIZER_RECEIVE_STATE:
_instance->MessageDeserializer_receive_State = MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE;
MessageDeserializer_receive_OnEntry(_instance->MessageDeserializer_receive_State, _instance);
break;
case MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE:
_instance->PacketManager_index_var = 0;
break;
case MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE:
break;
case MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE:
break;
default: break;
}
}

// On Exit Actions:
void MessageDeserializer_receive_OnExit(int state, struct MessageDeserializer_Instance *_instance) {
switch(state) {
case MESSAGEDESERIALIZER_RECEIVE_STATE:
MessageDeserializer_receive_OnExit(_instance->MessageDeserializer_receive_State, _instance);
break;
case MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE:
break;
case MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE:
break;
case MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void MessageDeserializer_handle_serial_serial_rx(struct MessageDeserializer_Instance *_instance, uint8_t b) {
if (_instance->MessageDeserializer_receive_State == MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE) {
if (b == _instance->PacketManager_START_BYTE_var) {
MessageDeserializer_receive_OnExit(MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE, _instance);
_instance->MessageDeserializer_receive_State = MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE;
MessageDeserializer_receive_OnEntry(MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE, _instance);
}
}
else if (_instance->MessageDeserializer_receive_State == MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE) {
if (b == _instance->PacketManager_ESCAPE_BYTE_var) {
MessageDeserializer_receive_OnExit(MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE, _instance);
_instance->MessageDeserializer_receive_State = MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE;
MessageDeserializer_receive_OnEntry(MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE, _instance);
}
else if (b == _instance->PacketManager_STOP_BYTE_var) {
MessageDeserializer_receive_OnExit(MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE, _instance);
_instance->MessageDeserializer_receive_State = MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE;
f_MessageDeserializer_forward(_instance);
MessageDeserializer_receive_OnEntry(MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE, _instance);
}
else if ( !(b == _instance->PacketManager_ESCAPE_BYTE_var || b == _instance->PacketManager_STOP_BYTE_var)) {
f_MessageDeserializer_storeByte(_instance, b);
}
else if (b == _instance->PacketManager_START_BYTE_var) {
_instance->PacketManager_index_var = 0;
}
}
else if (_instance->MessageDeserializer_receive_State == MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE) {
if (1) {
MessageDeserializer_receive_OnExit(MESSAGEDESERIALIZER_RECEIVE_ESCAPE_STATE, _instance);
_instance->MessageDeserializer_receive_State = MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE;
f_MessageDeserializer_storeByte(_instance, b);
MessageDeserializer_receive_OnEntry(MESSAGEDESERIALIZER_RECEIVE_RECEIVEMESSAGE_STATE, _instance);
}
}
}

// Observers for outgoing messages:
void (*MessageDeserializer_send_RemoteControl_changeDisplay_listener)(struct MessageDeserializer_Instance*)= 0x0;
void register_MessageDeserializer_send_RemoteControl_changeDisplay_listener(void (*_listener)(struct MessageDeserializer_Instance*)){
MessageDeserializer_send_RemoteControl_changeDisplay_listener = _listener;
}
void MessageDeserializer_send_RemoteControl_changeDisplay(struct MessageDeserializer_Instance *_instance){
if (MessageDeserializer_send_RemoteControl_changeDisplay_listener != 0x0) MessageDeserializer_send_RemoteControl_changeDisplay_listener(_instance);
}

/*****************************************************************************
 * Headers for type : AnalogInputArduino
 *****************************************************************************/


// BEGIN: Code from the c_header annotation AnalogInputArduino
#include <EEPROM.h>
// END: Code from the c_header annotation AnalogInputArduino

// Definition of the instance stuct:
struct AnalogInputArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int AnalogInputArduino_SimpleAnalogInputImp_State;
// Variables for the properties of the instance
uint8_t AnalogInputArduino_pin_var;
};

// Declaration of prototypes outgoing messages:
void AnalogInputArduino_SimpleAnalogInputImp_OnEntry(int state, struct AnalogInputArduino_Instance *_instance);
void AnalogInputArduino_handle_AnalogInput_read_analog_input(struct AnalogInputArduino_Instance *_instance);
void AnalogInputArduino_handle_AnalogIO_analog_read_result(struct AnalogInputArduino_Instance *_instance, uint8_t pin, int16_t value);
// Declaration of callbacks for incomming messages:
void register_AnalogInputArduino_send_AnalogIO_analog_read_listener(void (*_listener)(struct AnalogInputArduino_Instance*, uint8_t));
void register_AnalogInputArduino_send_AnalogInput_analog_input_value_listener(void (*_listener)(struct AnalogInputArduino_Instance*, int16_t));

// Definition of the states:
#define ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_STATE 0
#define ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE 1
#define ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE 2

/*****************************************************************************
 * Implementation for type : AnalogInputArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void AnalogInputArduino_SimpleAnalogInputImp_OnExit(int state, struct AnalogInputArduino_Instance *_instance);
void AnalogInputArduino_send_AnalogIO_analog_read(struct AnalogInputArduino_Instance *_instance, uint8_t pin);
void AnalogInputArduino_send_AnalogInput_analog_input_value(struct AnalogInputArduino_Instance *_instance, int16_t value);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void AnalogInputArduino_SimpleAnalogInputImp_OnEntry(int state, struct AnalogInputArduino_Instance *_instance) {
switch(state) {
case ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_STATE:
_instance->AnalogInputArduino_SimpleAnalogInputImp_State = ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE;
AnalogInputArduino_SimpleAnalogInputImp_OnEntry(_instance->AnalogInputArduino_SimpleAnalogInputImp_State, _instance);
break;
case ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE:
break;
case ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void AnalogInputArduino_SimpleAnalogInputImp_OnExit(int state, struct AnalogInputArduino_Instance *_instance) {
switch(state) {
case ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_STATE:
AnalogInputArduino_SimpleAnalogInputImp_OnExit(_instance->AnalogInputArduino_SimpleAnalogInputImp_State, _instance);
break;
case ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE:
break;
case ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void AnalogInputArduino_handle_AnalogInput_read_analog_input(struct AnalogInputArduino_Instance *_instance) {
if (_instance->AnalogInputArduino_SimpleAnalogInputImp_State == ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE) {
if (1) {
AnalogInputArduino_SimpleAnalogInputImp_OnExit(ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE, _instance);
_instance->AnalogInputArduino_SimpleAnalogInputImp_State = ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE;
AnalogInputArduino_send_AnalogIO_analog_read(_instance, _instance->AnalogInputArduino_pin_var);
AnalogInputArduino_SimpleAnalogInputImp_OnEntry(ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE, _instance);
}
}
}
void AnalogInputArduino_handle_AnalogIO_analog_read_result(struct AnalogInputArduino_Instance *_instance, uint8_t pin, int16_t value) {
if (_instance->AnalogInputArduino_SimpleAnalogInputImp_State == ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE) {
if (pin == _instance->AnalogInputArduino_pin_var) {
AnalogInputArduino_SimpleAnalogInputImp_OnExit(ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_WAITING_STATE, _instance);
_instance->AnalogInputArduino_SimpleAnalogInputImp_State = ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE;
AnalogInputArduino_send_AnalogInput_analog_input_value(_instance, value);
AnalogInputArduino_SimpleAnalogInputImp_OnEntry(ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE, _instance);
}
}
}

// Observers for outgoing messages:
void (*AnalogInputArduino_send_AnalogIO_analog_read_listener)(struct AnalogInputArduino_Instance*, uint8_t)= 0x0;
void register_AnalogInputArduino_send_AnalogIO_analog_read_listener(void (*_listener)(struct AnalogInputArduino_Instance*, uint8_t)){
AnalogInputArduino_send_AnalogIO_analog_read_listener = _listener;
}
void AnalogInputArduino_send_AnalogIO_analog_read(struct AnalogInputArduino_Instance *_instance, uint8_t pin){
if (AnalogInputArduino_send_AnalogIO_analog_read_listener != 0x0) AnalogInputArduino_send_AnalogIO_analog_read_listener(_instance, pin);
}
void (*AnalogInputArduino_send_AnalogInput_analog_input_value_listener)(struct AnalogInputArduino_Instance*, int16_t)= 0x0;
void register_AnalogInputArduino_send_AnalogInput_analog_input_value_listener(void (*_listener)(struct AnalogInputArduino_Instance*, int16_t)){
AnalogInputArduino_send_AnalogInput_analog_input_value_listener = _listener;
}
void AnalogInputArduino_send_AnalogInput_analog_input_value(struct AnalogInputArduino_Instance *_instance, int16_t value){
if (AnalogInputArduino_send_AnalogInput_analog_input_value_listener != 0x0) AnalogInputArduino_send_AnalogInput_analog_input_value_listener(_instance, value);
}

/*****************************************************************************
 * Headers for type : ArduinoArduino
 *****************************************************************************/


// BEGIN: Code from the c_header annotation ArduinoArduino
#include <EEPROM.h>
// END: Code from the c_header annotation ArduinoArduino

// Definition of the instance stuct:
struct ArduinoArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int ArduinoArduino_ArduinoArduino_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void ArduinoArduino_ArduinoArduino_OnEntry(int state, struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_handle_DigitalIO_digital_read(struct ArduinoArduino_Instance *_instance, uint8_t pin);
void ArduinoArduino_handle_DigitalIO_digital_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value);
void ArduinoArduino_handle_DigitalIO_pin_mode(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t mode);
void ArduinoArduino_handle_Ping_ping(struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_handle_AnalogIO_analog_reference(struct ArduinoArduino_Instance *_instance, uint8_t type);
void ArduinoArduino_handle_AnalogIO_analog_read(struct ArduinoArduino_Instance *_instance, uint8_t pin);
void ArduinoArduino_handle_AnalogIO_analog_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value);
void ArduinoArduino_handle_EEPROM_eeprom_read(struct ArduinoArduino_Instance *_instance, int16_t address);
void ArduinoArduino_handle_EEPROM_eeprom_sync_write(struct ArduinoArduino_Instance *_instance, int16_t address, int8_t value);
void ArduinoArduino_handle_EEPROM_eeprom_write(struct ArduinoArduino_Instance *_instance, int16_t address, int8_t value);
void ArduinoArduino_handle_AdvancedIO_no_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin);
void ArduinoArduino_handle_AdvancedIO_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin, int16_t frequency, int16_t duration);
// Declaration of callbacks for incomming messages:
void register_ArduinoArduino_send_DigitalIO_digital_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, uint8_t));
void register_ArduinoArduino_send_AnalogIO_analog_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, int16_t));
void register_ArduinoArduino_send_Ping_pong_listener(void (*_listener)(struct ArduinoArduino_Instance*));
void register_ArduinoArduino_send_EEPROM_eeprom_value_listener(void (*_listener)(struct ArduinoArduino_Instance*, int8_t));
void register_ArduinoArduino_send_EEPROM_eeprom_write_ack_listener(void (*_listener)(struct ArduinoArduino_Instance*));

// Definition of the states:
#define ARDUINOARDUINO_ARDUINOARDUINO_STATE 0
#define ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE 1

/*****************************************************************************
 * Implementation for type : ArduinoArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void ArduinoArduino_ArduinoArduino_OnExit(int state, struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_send_DigitalIO_digital_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value);
void ArduinoArduino_send_AnalogIO_analog_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, int16_t value);
void ArduinoArduino_send_Ping_pong(struct ArduinoArduino_Instance *_instance);
void ArduinoArduino_send_EEPROM_eeprom_value(struct ArduinoArduino_Instance *_instance, int8_t value);
void ArduinoArduino_send_EEPROM_eeprom_write_ack(struct ArduinoArduino_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void ArduinoArduino_ArduinoArduino_OnEntry(int state, struct ArduinoArduino_Instance *_instance) {
switch(state) {
case ARDUINOARDUINO_ARDUINOARDUINO_STATE:
_instance->ArduinoArduino_ArduinoArduino_State = ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE;
ArduinoArduino_ArduinoArduino_OnEntry(_instance->ArduinoArduino_ArduinoArduino_State, _instance);
break;
case ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE:
break;
default: break;
}
}

// On Exit Actions:
void ArduinoArduino_ArduinoArduino_OnExit(int state, struct ArduinoArduino_Instance *_instance) {
switch(state) {
case ARDUINOARDUINO_ARDUINOARDUINO_STATE:
ArduinoArduino_ArduinoArduino_OnExit(_instance->ArduinoArduino_ArduinoArduino_State, _instance);
break;
case ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void ArduinoArduino_handle_DigitalIO_digital_read(struct ArduinoArduino_Instance *_instance, uint8_t pin) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
ArduinoArduino_send_DigitalIO_digital_read_result(_instance, pin, digitalRead(pin));
}
}
}
void ArduinoArduino_handle_DigitalIO_digital_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
digitalWrite(pin, value);
}
}
}
void ArduinoArduino_handle_DigitalIO_pin_mode(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t mode) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
pinMode(pin, mode);
}
}
}
void ArduinoArduino_handle_Ping_ping(struct ArduinoArduino_Instance *_instance) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
ArduinoArduino_send_Ping_pong(_instance);
}
}
}
void ArduinoArduino_handle_AnalogIO_analog_reference(struct ArduinoArduino_Instance *_instance, uint8_t type) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
analogReference(type);
}
}
}
void ArduinoArduino_handle_AnalogIO_analog_read(struct ArduinoArduino_Instance *_instance, uint8_t pin) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
ArduinoArduino_send_AnalogIO_analog_read_result(_instance, pin, analogRead(pin));
}
}
}
void ArduinoArduino_handle_AnalogIO_analog_write(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
analogWrite(pin, value);
}
}
}
void ArduinoArduino_handle_EEPROM_eeprom_read(struct ArduinoArduino_Instance *_instance, int16_t address) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
ArduinoArduino_send_EEPROM_eeprom_value(_instance, EEPROM.read(address));
}
}
}
void ArduinoArduino_handle_EEPROM_eeprom_sync_write(struct ArduinoArduino_Instance *_instance, int16_t address, int8_t value) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
{
EEPROM.write(address, value);
ArduinoArduino_send_EEPROM_eeprom_write_ack(_instance);
}
}
}
}
void ArduinoArduino_handle_EEPROM_eeprom_write(struct ArduinoArduino_Instance *_instance, int16_t address, int8_t value) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
EEPROM.write(address, value);
}
}
}
void ArduinoArduino_handle_AdvancedIO_no_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
noTone(pin);
}
}
}
void ArduinoArduino_handle_AdvancedIO_tone(struct ArduinoArduino_Instance *_instance, uint8_t pin, int16_t frequency, int16_t duration) {
if (_instance->ArduinoArduino_ArduinoArduino_State == ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE) {
if (1) {
tone(pin, frequency, duration);
}
}
}

// Observers for outgoing messages:
void (*ArduinoArduino_send_DigitalIO_digital_read_result_listener)(struct ArduinoArduino_Instance*, uint8_t, uint8_t)= 0x0;
void register_ArduinoArduino_send_DigitalIO_digital_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, uint8_t)){
ArduinoArduino_send_DigitalIO_digital_read_result_listener = _listener;
}
void ArduinoArduino_send_DigitalIO_digital_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, uint8_t value){
if (ArduinoArduino_send_DigitalIO_digital_read_result_listener != 0x0) ArduinoArduino_send_DigitalIO_digital_read_result_listener(_instance, pin, value);
}
void (*ArduinoArduino_send_AnalogIO_analog_read_result_listener)(struct ArduinoArduino_Instance*, uint8_t, int16_t)= 0x0;
void register_ArduinoArduino_send_AnalogIO_analog_read_result_listener(void (*_listener)(struct ArduinoArduino_Instance*, uint8_t, int16_t)){
ArduinoArduino_send_AnalogIO_analog_read_result_listener = _listener;
}
void ArduinoArduino_send_AnalogIO_analog_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, int16_t value){
if (ArduinoArduino_send_AnalogIO_analog_read_result_listener != 0x0) ArduinoArduino_send_AnalogIO_analog_read_result_listener(_instance, pin, value);
}
void (*ArduinoArduino_send_Ping_pong_listener)(struct ArduinoArduino_Instance*)= 0x0;
void register_ArduinoArduino_send_Ping_pong_listener(void (*_listener)(struct ArduinoArduino_Instance*)){
ArduinoArduino_send_Ping_pong_listener = _listener;
}
void ArduinoArduino_send_Ping_pong(struct ArduinoArduino_Instance *_instance){
if (ArduinoArduino_send_Ping_pong_listener != 0x0) ArduinoArduino_send_Ping_pong_listener(_instance);
}
void (*ArduinoArduino_send_EEPROM_eeprom_value_listener)(struct ArduinoArduino_Instance*, int8_t)= 0x0;
void register_ArduinoArduino_send_EEPROM_eeprom_value_listener(void (*_listener)(struct ArduinoArduino_Instance*, int8_t)){
ArduinoArduino_send_EEPROM_eeprom_value_listener = _listener;
}
void ArduinoArduino_send_EEPROM_eeprom_value(struct ArduinoArduino_Instance *_instance, int8_t value){
if (ArduinoArduino_send_EEPROM_eeprom_value_listener != 0x0) ArduinoArduino_send_EEPROM_eeprom_value_listener(_instance, value);
}
void (*ArduinoArduino_send_EEPROM_eeprom_write_ack_listener)(struct ArduinoArduino_Instance*)= 0x0;
void register_ArduinoArduino_send_EEPROM_eeprom_write_ack_listener(void (*_listener)(struct ArduinoArduino_Instance*)){
ArduinoArduino_send_EEPROM_eeprom_write_ack_listener = _listener;
}
void ArduinoArduino_send_EEPROM_eeprom_write_ack(struct ArduinoArduino_Instance *_instance){
if (ArduinoArduino_send_EEPROM_eeprom_write_ack_listener != 0x0) ArduinoArduino_send_EEPROM_eeprom_write_ack_listener(_instance);
}

/*****************************************************************************
 * Headers for type : TimerArduino
 *****************************************************************************/

// Definition of the instance stuct:
struct TimerArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int TimerArduino_SoftTimer_State;
// Variables for the properties of the instance
long TimerArduino_SoftTimer_target_var;
};

// Declaration of prototypes outgoing messages:
void TimerArduino_SoftTimer_OnEntry(int state, struct TimerArduino_Instance *_instance);
void TimerArduino_handle_Polling_poll(struct TimerArduino_Instance *_instance);
void TimerArduino_handle_timer_timer_start(struct TimerArduino_Instance *_instance, int delay);
void TimerArduino_handle_timer_timer_cancel(struct TimerArduino_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_TimerArduino_send_timer_timer_timeout_listener(void (*_listener)(struct TimerArduino_Instance*));

// Definition of the states:
#define TIMERARDUINO_SOFTTIMER_STATE 0
#define TIMERARDUINO_SOFTTIMER_IDLE_STATE 1
#define TIMERARDUINO_SOFTTIMER_COUNTING_STATE 2

/*****************************************************************************
 * Implementation for type : TimerArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void TimerArduino_SoftTimer_OnExit(int state, struct TimerArduino_Instance *_instance);
void TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void TimerArduino_SoftTimer_OnEntry(int state, struct TimerArduino_Instance *_instance) {
switch(state) {
case TIMERARDUINO_SOFTTIMER_STATE:
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
TimerArduino_SoftTimer_OnEntry(_instance->TimerArduino_SoftTimer_State, _instance);
break;
case TIMERARDUINO_SOFTTIMER_IDLE_STATE:
break;
case TIMERARDUINO_SOFTTIMER_COUNTING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void TimerArduino_SoftTimer_OnExit(int state, struct TimerArduino_Instance *_instance) {
switch(state) {
case TIMERARDUINO_SOFTTIMER_STATE:
TimerArduino_SoftTimer_OnExit(_instance->TimerArduino_SoftTimer_State, _instance);
break;
case TIMERARDUINO_SOFTTIMER_IDLE_STATE:
break;
case TIMERARDUINO_SOFTTIMER_COUNTING_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void TimerArduino_handle_Polling_poll(struct TimerArduino_Instance *_instance) {
if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_COUNTING_STATE) {
if ( !(millis() < _instance->TimerArduino_SoftTimer_target_var)) {
TimerArduino_SoftTimer_OnExit(TIMERARDUINO_SOFTTIMER_COUNTING_STATE, _instance);
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_IDLE_STATE, _instance);
TimerArduino_send_timer_timer_timeout(_instance);
}
}
}
void TimerArduino_handle_timer_timer_start(struct TimerArduino_Instance *_instance, int delay) {
if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_IDLE_STATE) {
if (delay > 0) {
TimerArduino_SoftTimer_OnExit(TIMERARDUINO_SOFTTIMER_IDLE_STATE, _instance);
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_COUNTING_STATE;
_instance->TimerArduino_SoftTimer_target_var = millis() + delay;
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_COUNTING_STATE, _instance);
}
}
else if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_COUNTING_STATE) {
if (delay > 0) {
_instance->TimerArduino_SoftTimer_target_var = millis() + delay;
}
}
}
void TimerArduino_handle_timer_timer_cancel(struct TimerArduino_Instance *_instance) {
if (_instance->TimerArduino_SoftTimer_State == TIMERARDUINO_SOFTTIMER_COUNTING_STATE) {
if (1) {
TimerArduino_SoftTimer_OnExit(TIMERARDUINO_SOFTTIMER_COUNTING_STATE, _instance);
_instance->TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_IDLE_STATE, _instance);
}
}
}

// Observers for outgoing messages:
void (*TimerArduino_send_timer_timer_timeout_listener)(struct TimerArduino_Instance*)= 0x0;
void register_TimerArduino_send_timer_timer_timeout_listener(void (*_listener)(struct TimerArduino_Instance*)){
TimerArduino_send_timer_timer_timeout_listener = _listener;
}
void TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance){
if (TimerArduino_send_timer_timer_timeout_listener != 0x0) TimerArduino_send_timer_timer_timeout_listener(_instance);
}

/*****************************************************************************
 * Headers for type : OnChangeAnalogInput
 *****************************************************************************/

// Definition of the instance stuct:
struct OnChangeAnalogInput_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int OnChangeAnalogInput_OnChangeAnalogInputImpl_State;
// Variables for the properties of the instance
uint8_t OnChangeAnalogInput_refresh_rate_var;
int16_t OnChangeAnalogInput_OnChangeAnalogInputImpl_oldValue_var;
};

// Declaration of prototypes outgoing messages:
void OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(int state, struct OnChangeAnalogInput_Instance *_instance);
void OnChangeAnalogInput_handle_Timer_timer_timeout(struct OnChangeAnalogInput_Instance *_instance);
void OnChangeAnalogInput_handle_AnalogInput_analog_input_value(struct OnChangeAnalogInput_Instance *_instance, int16_t value);
// Declaration of callbacks for incomming messages:
void register_OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value_listener(void (*_listener)(struct OnChangeAnalogInput_Instance*, int16_t));
void register_OnChangeAnalogInput_send_Timer_timer_start_listener(void (*_listener)(struct OnChangeAnalogInput_Instance*, int));
void register_OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener(void (*_listener)(struct OnChangeAnalogInput_Instance*));

// Definition of the states:
#define ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_STATE 0
#define ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE 1
#define ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE 2

/*****************************************************************************
 * Implementation for type : OnChangeAnalogInput
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void OnChangeAnalogInput_OnChangeAnalogInputImpl_OnExit(int state, struct OnChangeAnalogInput_Instance *_instance);
void OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value(struct OnChangeAnalogInput_Instance *_instance, int16_t value);
void OnChangeAnalogInput_send_Timer_timer_start(struct OnChangeAnalogInput_Instance *_instance, int delay);
void OnChangeAnalogInput_send_AnalogInput_read_analog_input(struct OnChangeAnalogInput_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(int state, struct OnChangeAnalogInput_Instance *_instance) {
switch(state) {
case ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_STATE:
_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State = ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE;
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State, _instance);
break;
case ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE:
OnChangeAnalogInput_send_Timer_timer_start(_instance, _instance->OnChangeAnalogInput_refresh_rate_var);
break;
case ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void OnChangeAnalogInput_OnChangeAnalogInputImpl_OnExit(int state, struct OnChangeAnalogInput_Instance *_instance) {
switch(state) {
case ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_STATE:
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnExit(_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State, _instance);
break;
case ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE:
break;
case ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void OnChangeAnalogInput_handle_Timer_timer_timeout(struct OnChangeAnalogInput_Instance *_instance) {
if (_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State == ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE) {
if (1) {
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnExit(ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE, _instance);
_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State = ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE;
OnChangeAnalogInput_send_AnalogInput_read_analog_input(_instance);
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE, _instance);
}
}
}
void OnChangeAnalogInput_handle_AnalogInput_analog_input_value(struct OnChangeAnalogInput_Instance *_instance, int16_t value) {
if (_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State == ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE) {
if (1) {
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnExit(ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_WAITING_STATE, _instance);
_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_State = ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE;
{
if( !(value == _instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_oldValue_var)) {
OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value(_instance, value);
_instance->OnChangeAnalogInput_OnChangeAnalogInputImpl_oldValue_var = value;
}
}
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE, _instance);
}
}
}

// Observers for outgoing messages:
void (*OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value_listener)(struct OnChangeAnalogInput_Instance*, int16_t)= 0x0;
void register_OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value_listener(void (*_listener)(struct OnChangeAnalogInput_Instance*, int16_t)){
OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value_listener = _listener;
}
void OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value(struct OnChangeAnalogInput_Instance *_instance, int16_t value){
if (OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value_listener != 0x0) OnChangeAnalogInput_send_OnChangeAnalogInput_analog_input_value_listener(_instance, value);
}
void (*OnChangeAnalogInput_send_Timer_timer_start_listener)(struct OnChangeAnalogInput_Instance*, int)= 0x0;
void register_OnChangeAnalogInput_send_Timer_timer_start_listener(void (*_listener)(struct OnChangeAnalogInput_Instance*, int)){
OnChangeAnalogInput_send_Timer_timer_start_listener = _listener;
}
void OnChangeAnalogInput_send_Timer_timer_start(struct OnChangeAnalogInput_Instance *_instance, int delay){
if (OnChangeAnalogInput_send_Timer_timer_start_listener != 0x0) OnChangeAnalogInput_send_Timer_timer_start_listener(_instance, delay);
}
void (*OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener)(struct OnChangeAnalogInput_Instance*)= 0x0;
void register_OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener(void (*_listener)(struct OnChangeAnalogInput_Instance*)){
OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener = _listener;
}
void OnChangeAnalogInput_send_AnalogInput_read_analog_input(struct OnChangeAnalogInput_Instance *_instance){
if (OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener != 0x0) OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener(_instance);
}

/*****************************************************************************
 * Headers for type : MessageSerializer
 *****************************************************************************/

// Definition of the instance stuct:
struct MessageSerializer_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int MessageSerializer_SerializerBehavior_State;
// Variables for the properties of the instance
uint8_t PacketManager_lengthInteger_var;
uint8_t PacketManager_lengthString_var;
uint8_t PacketManager_lengthUInt16_var;
int PacketManager_MAX_PACKET_SIZE_var;
uint8_t PacketManager_START_BYTE_var;
uint8_t PacketManager_STOP_BYTE_var;
uint8_t PacketManager_ESCAPE_BYTE_var;
int PacketManager_CODE_POSITION_var;
int PacketManager_LENGTH_POSITION_var;
int PacketManager_DATA_POSITION_var;
uint8_t PacketManager_buffer_var[16];
int PacketManager_index_var;
};

// Declaration of prototypes outgoing messages:
void MessageSerializer_SerializerBehavior_OnEntry(int state, struct MessageSerializer_Instance *_instance);
void MessageSerializer_handle_RemoteControl_temperature(struct MessageSerializer_Instance *_instance, uint16_t temp);
void MessageSerializer_handle_RemoteControl_light(struct MessageSerializer_Instance *_instance, uint16_t light);
// Declaration of callbacks for incomming messages:
void register_MessageSerializer_send_serial_serial_tx_listener(void (*_listener)(struct MessageSerializer_Instance*, uint8_t));

// Definition of the states:
#define MESSAGESERIALIZER_SERIALIZERBEHAVIOR_STATE 0
#define MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE 1

/*****************************************************************************
 * Implementation for type : MessageSerializer
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void MessageSerializer_SerializerBehavior_OnExit(int state, struct MessageSerializer_Instance *_instance);
void MessageSerializer_send_serial_serial_tx(struct MessageSerializer_Instance *_instance, uint8_t b);
void f_MessageSerializer_serializeInteger(struct MessageSerializer_Instance *_instance, int d);
void f_MessageSerializer_serializeUInt16(struct MessageSerializer_Instance *_instance, uint16_t d);
void f_MessageSerializer_send(struct MessageSerializer_Instance *_instance);
void f_MessageSerializer_setHeader(struct MessageSerializer_Instance *_instance, uint8_t code, uint8_t length);
void f_MessageSerializer_storeByte(struct MessageSerializer_Instance *_instance, uint8_t b);
uint8_t f_MessageSerializer_readByte(struct MessageSerializer_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:
// Definition of function serializeInteger
void f_MessageSerializer_serializeInteger(struct MessageSerializer_Instance *_instance, int d) {
{
f_MessageSerializer_storeByte(_instance, (d >> 8) & 0x00ff);
f_MessageSerializer_storeByte(_instance, (d) & 0x00ff);
}
}

// Definition of function serializeUInt16
void f_MessageSerializer_serializeUInt16(struct MessageSerializer_Instance *_instance, uint16_t d) {
{
f_MessageSerializer_storeByte(_instance, (d >> 8) & 0x00ff);
f_MessageSerializer_storeByte(_instance, (d) & 0x00ff);
}
}

// Definition of function send
void f_MessageSerializer_send(struct MessageSerializer_Instance *_instance) {
{
MessageSerializer_send_serial_serial_tx(_instance, _instance->PacketManager_START_BYTE_var);
int stop = _instance->PacketManager_DATA_POSITION_var + _instance->PacketManager_buffer_var[_instance->PacketManager_LENGTH_POSITION_var];
int i = 0;
while(i < stop) {
uint8_t b = _instance->PacketManager_buffer_var[i];
if(b == _instance->PacketManager_START_BYTE_var || b == _instance->PacketManager_STOP_BYTE_var || b == _instance->PacketManager_ESCAPE_BYTE_var) {
MessageSerializer_send_serial_serial_tx(_instance, _instance->PacketManager_ESCAPE_BYTE_var);
}
MessageSerializer_send_serial_serial_tx(_instance, b);
i = i + 1;
}
MessageSerializer_send_serial_serial_tx(_instance, _instance->PacketManager_STOP_BYTE_var);
_instance->PacketManager_index_var = 0;
}
}

// Definition of function setHeader
void f_MessageSerializer_setHeader(struct MessageSerializer_Instance *_instance, uint8_t code, uint8_t length) {
{
_instance->PacketManager_index_var = 0;
f_MessageSerializer_storeByte(_instance, 1);
f_MessageSerializer_storeByte(_instance, 0);
f_MessageSerializer_storeByte(_instance, 0);
_instance->PacketManager_CODE_POSITION_var = _instance->PacketManager_index_var;
f_MessageSerializer_storeByte(_instance, code);
_instance->PacketManager_LENGTH_POSITION_var = _instance->PacketManager_index_var;
f_MessageSerializer_storeByte(_instance, length);
_instance->PacketManager_DATA_POSITION_var = _instance->PacketManager_index_var;
_instance->PacketManager_index_var = _instance->PacketManager_DATA_POSITION_var;
}
}

// Definition of function storeByte
void f_MessageSerializer_storeByte(struct MessageSerializer_Instance *_instance, uint8_t b) {
{
if(_instance->PacketManager_index_var == _instance->PacketManager_MAX_PACKET_SIZE_var) {
// ERROR: ("BUFFER OVERFLOW\n")
}
if(_instance->PacketManager_index_var < _instance->PacketManager_MAX_PACKET_SIZE_var) {
_instance->PacketManager_buffer_var[_instance->PacketManager_index_var] = b;
_instance->PacketManager_index_var = _instance->PacketManager_index_var + 1;
}
}
}

// Definition of function readByte
uint8_t f_MessageSerializer_readByte(struct MessageSerializer_Instance *_instance) {
{
uint8_t b;
if(_instance->PacketManager_index_var < _instance->PacketManager_MAX_PACKET_SIZE_var) {
b = _instance->PacketManager_buffer_var[_instance->PacketManager_index_var];
_instance->PacketManager_index_var = _instance->PacketManager_index_var + 1;
}
if(_instance->PacketManager_index_var == _instance->PacketManager_MAX_PACKET_SIZE_var) {
// ERROR: ("BUFFER OVERFLOW: trying to read out of buffer boundaries")
b = _instance->PacketManager_STOP_BYTE_var;
}
return b;
}
}


// On Entry Actions:
void MessageSerializer_SerializerBehavior_OnEntry(int state, struct MessageSerializer_Instance *_instance) {
switch(state) {
case MESSAGESERIALIZER_SERIALIZERBEHAVIOR_STATE:
_instance->MessageSerializer_SerializerBehavior_State = MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE;
MessageSerializer_SerializerBehavior_OnEntry(_instance->MessageSerializer_SerializerBehavior_State, _instance);
break;
case MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE:
break;
default: break;
}
}

// On Exit Actions:
void MessageSerializer_SerializerBehavior_OnExit(int state, struct MessageSerializer_Instance *_instance) {
switch(state) {
case MESSAGESERIALIZER_SERIALIZERBEHAVIOR_STATE:
MessageSerializer_SerializerBehavior_OnExit(_instance->MessageSerializer_SerializerBehavior_State, _instance);
break;
case MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void MessageSerializer_handle_RemoteControl_temperature(struct MessageSerializer_Instance *_instance, uint16_t temp) {
if (_instance->MessageSerializer_SerializerBehavior_State == MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE) {
if (1) {
{
f_MessageSerializer_setHeader(_instance, 10, _instance->PacketManager_lengthUInt16_var);
f_MessageSerializer_serializeUInt16(_instance, temp);
f_MessageSerializer_send(_instance);
}
}
}
}
void MessageSerializer_handle_RemoteControl_light(struct MessageSerializer_Instance *_instance, uint16_t light) {
if (_instance->MessageSerializer_SerializerBehavior_State == MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE) {
if (1) {
{
f_MessageSerializer_setHeader(_instance, 11, _instance->PacketManager_lengthUInt16_var);
f_MessageSerializer_serializeUInt16(_instance, light);
f_MessageSerializer_send(_instance);
}
}
}
}

// Observers for outgoing messages:
void (*MessageSerializer_send_serial_serial_tx_listener)(struct MessageSerializer_Instance*, uint8_t)= 0x0;
void register_MessageSerializer_send_serial_serial_tx_listener(void (*_listener)(struct MessageSerializer_Instance*, uint8_t)){
MessageSerializer_send_serial_serial_tx_listener = _listener;
}
void MessageSerializer_send_serial_serial_tx(struct MessageSerializer_Instance *_instance, uint8_t b){
if (MessageSerializer_send_serial_serial_tx_listener != 0x0) MessageSerializer_send_serial_serial_tx_listener(_instance, b);
}

/*****************************************************************************
 * Headers for type : SensorsDisplay
 *****************************************************************************/

// Definition of the instance stuct:
struct SensorsDisplay_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int SensorsDisplay_SensorsDisplayImpl_State;
// Variables for the properties of the instance
uint8_t SensorsDisplay_tempDisplay_var;
uint8_t SensorsDisplay_lightDisplay_var;
uint16_t SensorsDisplay_temp_var;
uint16_t SensorsDisplay_light_var;
uint16_t SensorsDisplay_period_var;
};

// Declaration of prototypes outgoing messages:
void SensorsDisplay_SensorsDisplayImpl_OnEntry(int state, struct SensorsDisplay_Instance *_instance);
void SensorsDisplay_handle_LightSensor_light_value(struct SensorsDisplay_Instance *_instance, uint16_t val);
void SensorsDisplay_handle_RemoteControl_changeDisplay(struct SensorsDisplay_Instance *_instance);
void SensorsDisplay_handle_TemperatureSensor_temperature_value(struct SensorsDisplay_Instance *_instance, int16_t val);
// Declaration of callbacks for incomming messages:
void register_SensorsDisplay_send_RemoteControl_temperature_listener(void (*_listener)(struct SensorsDisplay_Instance*, uint16_t));
void register_SensorsDisplay_send_RemoteControl_light_listener(void (*_listener)(struct SensorsDisplay_Instance*, uint16_t));
void register_SensorsDisplay_send_TemperatureSensor_read_temperature_listener(void (*_listener)(struct SensorsDisplay_Instance*));
void register_SensorsDisplay_send_LightSensor_read_light_listener(void (*_listener)(struct SensorsDisplay_Instance*));

// Definition of the states:
#define SENSORSDISPLAY_SENSORSDISPLAYIMPL_STATE 0
#define SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE 1
#define SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE 2

/*****************************************************************************
 * Implementation for type : SensorsDisplay
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void SensorsDisplay_SensorsDisplayImpl_OnExit(int state, struct SensorsDisplay_Instance *_instance);
void SensorsDisplay_send_RemoteControl_temperature(struct SensorsDisplay_Instance *_instance, uint16_t temp);
void SensorsDisplay_send_RemoteControl_light(struct SensorsDisplay_Instance *_instance, uint16_t light);
void SensorsDisplay_send_TemperatureSensor_read_temperature(struct SensorsDisplay_Instance *_instance);
void SensorsDisplay_send_LightSensor_read_light(struct SensorsDisplay_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void SensorsDisplay_SensorsDisplayImpl_OnEntry(int state, struct SensorsDisplay_Instance *_instance) {
switch(state) {
case SENSORSDISPLAY_SENSORSDISPLAYIMPL_STATE:
_instance->SensorsDisplay_SensorsDisplayImpl_State = SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE;
SensorsDisplay_SensorsDisplayImpl_OnEntry(_instance->SensorsDisplay_SensorsDisplayImpl_State, _instance);
break;
case SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE:
break;
case SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE:
break;
default: break;
}
}

// On Exit Actions:
void SensorsDisplay_SensorsDisplayImpl_OnExit(int state, struct SensorsDisplay_Instance *_instance) {
switch(state) {
case SENSORSDISPLAY_SENSORSDISPLAYIMPL_STATE:
SensorsDisplay_SensorsDisplayImpl_OnExit(_instance->SensorsDisplay_SensorsDisplayImpl_State, _instance);
break;
case SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE:
{
SensorsDisplay_send_RemoteControl_temperature(_instance, _instance->SensorsDisplay_temp_var);
}
break;
case SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE:
{
SensorsDisplay_send_RemoteControl_light(_instance, _instance->SensorsDisplay_light_var);
}
break;
default: break;
}
}

// Event Handlers for incomming messages:
void SensorsDisplay_handle_LightSensor_light_value(struct SensorsDisplay_Instance *_instance, uint16_t val) {
if (1) {
{
_instance->SensorsDisplay_light_var = val;
}
}
}
void SensorsDisplay_handle_RemoteControl_changeDisplay(struct SensorsDisplay_Instance *_instance) {
if (_instance->SensorsDisplay_SensorsDisplayImpl_State == SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE) {
if (1) {
SensorsDisplay_SensorsDisplayImpl_OnExit(SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE, _instance);
_instance->SensorsDisplay_SensorsDisplayImpl_State = SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE;
SensorsDisplay_SensorsDisplayImpl_OnEntry(SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE, _instance);
}
}
else if (_instance->SensorsDisplay_SensorsDisplayImpl_State == SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE) {
if (1) {
SensorsDisplay_SensorsDisplayImpl_OnExit(SENSORSDISPLAY_SENSORSDISPLAYIMPL_LIGHT_STATE, _instance);
_instance->SensorsDisplay_SensorsDisplayImpl_State = SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE;
SensorsDisplay_SensorsDisplayImpl_OnEntry(SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE, _instance);
}
}
}
void SensorsDisplay_handle_TemperatureSensor_temperature_value(struct SensorsDisplay_Instance *_instance, int16_t val) {
if (1) {
{
_instance->SensorsDisplay_temp_var = val;
}
}
}

// Observers for outgoing messages:
void (*SensorsDisplay_send_RemoteControl_temperature_listener)(struct SensorsDisplay_Instance*, uint16_t)= 0x0;
void register_SensorsDisplay_send_RemoteControl_temperature_listener(void (*_listener)(struct SensorsDisplay_Instance*, uint16_t)){
SensorsDisplay_send_RemoteControl_temperature_listener = _listener;
}
void SensorsDisplay_send_RemoteControl_temperature(struct SensorsDisplay_Instance *_instance, uint16_t temp){
if (SensorsDisplay_send_RemoteControl_temperature_listener != 0x0) SensorsDisplay_send_RemoteControl_temperature_listener(_instance, temp);
}
void (*SensorsDisplay_send_RemoteControl_light_listener)(struct SensorsDisplay_Instance*, uint16_t)= 0x0;
void register_SensorsDisplay_send_RemoteControl_light_listener(void (*_listener)(struct SensorsDisplay_Instance*, uint16_t)){
SensorsDisplay_send_RemoteControl_light_listener = _listener;
}
void SensorsDisplay_send_RemoteControl_light(struct SensorsDisplay_Instance *_instance, uint16_t light){
if (SensorsDisplay_send_RemoteControl_light_listener != 0x0) SensorsDisplay_send_RemoteControl_light_listener(_instance, light);
}
void (*SensorsDisplay_send_TemperatureSensor_read_temperature_listener)(struct SensorsDisplay_Instance*)= 0x0;
void register_SensorsDisplay_send_TemperatureSensor_read_temperature_listener(void (*_listener)(struct SensorsDisplay_Instance*)){
SensorsDisplay_send_TemperatureSensor_read_temperature_listener = _listener;
}
void SensorsDisplay_send_TemperatureSensor_read_temperature(struct SensorsDisplay_Instance *_instance){
if (SensorsDisplay_send_TemperatureSensor_read_temperature_listener != 0x0) SensorsDisplay_send_TemperatureSensor_read_temperature_listener(_instance);
}
void (*SensorsDisplay_send_LightSensor_read_light_listener)(struct SensorsDisplay_Instance*)= 0x0;
void register_SensorsDisplay_send_LightSensor_read_light_listener(void (*_listener)(struct SensorsDisplay_Instance*)){
SensorsDisplay_send_LightSensor_read_light_listener = _listener;
}
void SensorsDisplay_send_LightSensor_read_light(struct SensorsDisplay_Instance *_instance){
if (SensorsDisplay_send_LightSensor_read_light_listener != 0x0) SensorsDisplay_send_LightSensor_read_light_listener(_instance);
}

/*****************************************************************************
 * Headers for type : LightSensor
 *****************************************************************************/

// Definition of the instance stuct:
struct LightSensor_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int LightSensor_LightSensorImpl_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void LightSensor_LightSensorImpl_OnEntry(int state, struct LightSensor_Instance *_instance);
void LightSensor_handle_AnalogInput_analog_input_value(struct LightSensor_Instance *_instance, int16_t value);
void LightSensor_handle_LightSensor_read_light(struct LightSensor_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_LightSensor_send_LightSensor_light_value_listener(void (*_listener)(struct LightSensor_Instance*, uint16_t));
void register_LightSensor_send_AnalogInput_read_analog_input_listener(void (*_listener)(struct LightSensor_Instance*));

// Definition of the states:
#define LIGHTSENSOR_LIGHTSENSORIMPL_STATE 0
#define LIGHTSENSOR_LIGHTSENSORIMPL_RUNNING_STATE 1

/*****************************************************************************
 * Implementation for type : LightSensor
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void LightSensor_LightSensorImpl_OnExit(int state, struct LightSensor_Instance *_instance);
void LightSensor_send_LightSensor_light_value(struct LightSensor_Instance *_instance, uint16_t val);
void LightSensor_send_AnalogInput_read_analog_input(struct LightSensor_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void LightSensor_LightSensorImpl_OnEntry(int state, struct LightSensor_Instance *_instance) {
switch(state) {
case LIGHTSENSOR_LIGHTSENSORIMPL_STATE:
_instance->LightSensor_LightSensorImpl_State = LIGHTSENSOR_LIGHTSENSORIMPL_RUNNING_STATE;
LightSensor_LightSensorImpl_OnEntry(_instance->LightSensor_LightSensorImpl_State, _instance);
break;
case LIGHTSENSOR_LIGHTSENSORIMPL_RUNNING_STATE:
break;
default: break;
}
}

// On Exit Actions:
void LightSensor_LightSensorImpl_OnExit(int state, struct LightSensor_Instance *_instance) {
switch(state) {
case LIGHTSENSOR_LIGHTSENSORIMPL_STATE:
LightSensor_LightSensorImpl_OnExit(_instance->LightSensor_LightSensorImpl_State, _instance);
break;
case LIGHTSENSOR_LIGHTSENSORIMPL_RUNNING_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void LightSensor_handle_AnalogInput_analog_input_value(struct LightSensor_Instance *_instance, int16_t value) {
if (1) {
LightSensor_send_LightSensor_light_value(_instance, value);
}
}
void LightSensor_handle_LightSensor_read_light(struct LightSensor_Instance *_instance) {
if (_instance->LightSensor_LightSensorImpl_State == LIGHTSENSOR_LIGHTSENSORIMPL_RUNNING_STATE) {
if (1) {
LightSensor_send_AnalogInput_read_analog_input(_instance);
}
}
}

// Observers for outgoing messages:
void (*LightSensor_send_LightSensor_light_value_listener)(struct LightSensor_Instance*, uint16_t)= 0x0;
void register_LightSensor_send_LightSensor_light_value_listener(void (*_listener)(struct LightSensor_Instance*, uint16_t)){
LightSensor_send_LightSensor_light_value_listener = _listener;
}
void LightSensor_send_LightSensor_light_value(struct LightSensor_Instance *_instance, uint16_t val){
if (LightSensor_send_LightSensor_light_value_listener != 0x0) LightSensor_send_LightSensor_light_value_listener(_instance, val);
}
void (*LightSensor_send_AnalogInput_read_analog_input_listener)(struct LightSensor_Instance*)= 0x0;
void register_LightSensor_send_AnalogInput_read_analog_input_listener(void (*_listener)(struct LightSensor_Instance*)){
LightSensor_send_AnalogInput_read_analog_input_listener = _listener;
}
void LightSensor_send_AnalogInput_read_analog_input(struct LightSensor_Instance *_instance){
if (LightSensor_send_AnalogInput_read_analog_input_listener != 0x0) LightSensor_send_AnalogInput_read_analog_input_listener(_instance);
}

/*****************************************************************************
 * Headers for type : SerialArduino
 *****************************************************************************/

// Definition of the instance stuct:
struct SerialArduino_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int SerialArduino_SerialImpl_State;
// Variables for the properties of the instance
};

// Declaration of prototypes outgoing messages:
void SerialArduino_SerialImpl_OnEntry(int state, struct SerialArduino_Instance *_instance);
void SerialArduino_handle_serial_serial_tx(struct SerialArduino_Instance *_instance, uint8_t b);
void SerialArduino_handle_Polling_poll(struct SerialArduino_Instance *_instance);
// Declaration of callbacks for incomming messages:
void register_SerialArduino_send_serial_serial_rx_listener(void (*_listener)(struct SerialArduino_Instance*, uint8_t));
void register_SerialArduino_send_serial_serial_closed_listener(void (*_listener)(struct SerialArduino_Instance*));
void register_SerialArduino_send_serial_serial_opened_listener(void (*_listener)(struct SerialArduino_Instance*));

// Definition of the states:
#define SERIALARDUINO_SERIALIMPL_STATE 0
#define SERIALARDUINO_SERIALIMPL_RECEIVING_STATE 1

/*****************************************************************************
 * Implementation for type : SerialArduino
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void SerialArduino_SerialImpl_OnExit(int state, struct SerialArduino_Instance *_instance);
void SerialArduino_send_serial_serial_rx(struct SerialArduino_Instance *_instance, uint8_t b);
void SerialArduino_send_serial_serial_closed(struct SerialArduino_Instance *_instance);
void SerialArduino_send_serial_serial_opened(struct SerialArduino_Instance *_instance);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:

// On Entry Actions:
void SerialArduino_SerialImpl_OnEntry(int state, struct SerialArduino_Instance *_instance) {
switch(state) {
case SERIALARDUINO_SERIALIMPL_STATE:
_instance->SerialArduino_SerialImpl_State = SERIALARDUINO_SERIALIMPL_RECEIVING_STATE;
SerialArduino_SerialImpl_OnEntry(_instance->SerialArduino_SerialImpl_State, _instance);
break;
case SERIALARDUINO_SERIALIMPL_RECEIVING_STATE:
Serial.begin(9600);
break;
default: break;
}
}

// On Exit Actions:
void SerialArduino_SerialImpl_OnExit(int state, struct SerialArduino_Instance *_instance) {
switch(state) {
case SERIALARDUINO_SERIALIMPL_STATE:
SerialArduino_SerialImpl_OnExit(_instance->SerialArduino_SerialImpl_State, _instance);
break;
case SERIALARDUINO_SERIALIMPL_RECEIVING_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void SerialArduino_handle_serial_serial_tx(struct SerialArduino_Instance *_instance, uint8_t b) {
if (_instance->SerialArduino_SerialImpl_State == SERIALARDUINO_SERIALIMPL_RECEIVING_STATE) {
if (1) {
Serial.print(b);
}
}
}
void SerialArduino_handle_Polling_poll(struct SerialArduino_Instance *_instance) {
if (_instance->SerialArduino_SerialImpl_State == SERIALARDUINO_SERIALIMPL_RECEIVING_STATE) {
if (Serial.available() > 0) {
SerialArduino_send_serial_serial_rx(_instance, (char)Serial.read());
}
}
}

// Observers for outgoing messages:
void (*SerialArduino_send_serial_serial_rx_listener)(struct SerialArduino_Instance*, uint8_t)= 0x0;
void register_SerialArduino_send_serial_serial_rx_listener(void (*_listener)(struct SerialArduino_Instance*, uint8_t)){
SerialArduino_send_serial_serial_rx_listener = _listener;
}
void SerialArduino_send_serial_serial_rx(struct SerialArduino_Instance *_instance, uint8_t b){
if (SerialArduino_send_serial_serial_rx_listener != 0x0) SerialArduino_send_serial_serial_rx_listener(_instance, b);
}
void (*SerialArduino_send_serial_serial_closed_listener)(struct SerialArduino_Instance*)= 0x0;
void register_SerialArduino_send_serial_serial_closed_listener(void (*_listener)(struct SerialArduino_Instance*)){
SerialArduino_send_serial_serial_closed_listener = _listener;
}
void SerialArduino_send_serial_serial_closed(struct SerialArduino_Instance *_instance){
if (SerialArduino_send_serial_serial_closed_listener != 0x0) SerialArduino_send_serial_serial_closed_listener(_instance);
}
void (*SerialArduino_send_serial_serial_opened_listener)(struct SerialArduino_Instance*)= 0x0;
void register_SerialArduino_send_serial_serial_opened_listener(void (*_listener)(struct SerialArduino_Instance*)){
SerialArduino_send_serial_serial_opened_listener = _listener;
}
void SerialArduino_send_serial_serial_opened(struct SerialArduino_Instance *_instance){
if (SerialArduino_send_serial_serial_opened_listener != 0x0) SerialArduino_send_serial_serial_opened_listener(_instance);
}

/*****************************************************************************
 * Headers for type : TemperatureSensor
 *****************************************************************************/


// BEGIN: Code from the c_header annotation TemperatureSensor
#include <math.h>
// END: Code from the c_header annotation TemperatureSensor

// Definition of the instance stuct:
struct TemperatureSensor_Instance {
// Variables for the ID of the instance
int id;
// Variables for the current instance state
int TemperatureSensor_TempSensorImpl_State;
// Variables for the properties of the instance
int16_t TemperatureSensor_temp_var;
};

// Declaration of prototypes outgoing messages:
void TemperatureSensor_TempSensorImpl_OnEntry(int state, struct TemperatureSensor_Instance *_instance);
void TemperatureSensor_handle_TemperatureSensor_read_temperature(struct TemperatureSensor_Instance *_instance);
void TemperatureSensor_handle_AnalogInput_analog_input_value(struct TemperatureSensor_Instance *_instance, int16_t value);
// Declaration of callbacks for incomming messages:
void register_TemperatureSensor_send_TemperatureSensor_temperature_value_listener(void (*_listener)(struct TemperatureSensor_Instance*, int16_t));
void register_TemperatureSensor_send_AnalogInput_read_analog_input_listener(void (*_listener)(struct TemperatureSensor_Instance*));

// Definition of the states:
#define TEMPERATURESENSOR_TEMPSENSORIMPL_STATE 0
#define TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE 1
#define TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE 2

/*****************************************************************************
 * Implementation for type : TemperatureSensor
 *****************************************************************************/

// Declaration of prototypes:
#ifdef EXTERN_C_PROTOTYPES
extern "C" {
#endif
void TemperatureSensor_TempSensorImpl_OnExit(int state, struct TemperatureSensor_Instance *_instance);
void TemperatureSensor_send_TemperatureSensor_temperature_value(struct TemperatureSensor_Instance *_instance, int16_t val);
void TemperatureSensor_send_AnalogInput_read_analog_input(struct TemperatureSensor_Instance *_instance);
int16_t f_TemperatureSensor_convertTemperature(struct TemperatureSensor_Instance *_instance, int16_t adc);
#ifdef EXTERN_C_PROTOTYPES
}
#endif

// Declaration of functions:
// Definition of function convertTemperature
int16_t f_TemperatureSensor_convertTemperature(struct TemperatureSensor_Instance *_instance, int16_t adc) {
{
double tmp;
tmp = log((10240000 / adc) - 10000);
tmp = 1 / (0.001129148 + (0.000234125 + (0.0000000876741 * tmp * tmp)) * tmp);
tmp = tmp - 273.15;
return (int)tmp;
}
}


// On Entry Actions:
void TemperatureSensor_TempSensorImpl_OnEntry(int state, struct TemperatureSensor_Instance *_instance) {
switch(state) {
case TEMPERATURESENSOR_TEMPSENSORIMPL_STATE:
_instance->TemperatureSensor_TempSensorImpl_State = TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE;
TemperatureSensor_TempSensorImpl_OnEntry(_instance->TemperatureSensor_TempSensorImpl_State, _instance);
break;
case TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE:
break;
case TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE:
break;
default: break;
}
}

// On Exit Actions:
void TemperatureSensor_TempSensorImpl_OnExit(int state, struct TemperatureSensor_Instance *_instance) {
switch(state) {
case TEMPERATURESENSOR_TEMPSENSORIMPL_STATE:
TemperatureSensor_TempSensorImpl_OnExit(_instance->TemperatureSensor_TempSensorImpl_State, _instance);
break;
case TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE:
break;
case TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE:
break;
default: break;
}
}

// Event Handlers for incomming messages:
void TemperatureSensor_handle_TemperatureSensor_read_temperature(struct TemperatureSensor_Instance *_instance) {
if (_instance->TemperatureSensor_TempSensorImpl_State == TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE) {
if (1) {
TemperatureSensor_TempSensorImpl_OnExit(TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE, _instance);
_instance->TemperatureSensor_TempSensorImpl_State = TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE;
TemperatureSensor_send_AnalogInput_read_analog_input(_instance);
TemperatureSensor_TempSensorImpl_OnEntry(TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE, _instance);
}
}
}
void TemperatureSensor_handle_AnalogInput_analog_input_value(struct TemperatureSensor_Instance *_instance, int16_t value) {
if (_instance->TemperatureSensor_TempSensorImpl_State == TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE) {
if (1) {
{
TemperatureSensor_send_TemperatureSensor_temperature_value(_instance, (_instance->TemperatureSensor_temp_var + f_TemperatureSensor_convertTemperature(_instance, value)) / 2);
_instance->TemperatureSensor_temp_var = f_TemperatureSensor_convertTemperature(_instance, value);
}
}
}
else if (_instance->TemperatureSensor_TempSensorImpl_State == TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE) {
if (1) {
TemperatureSensor_TempSensorImpl_OnExit(TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE, _instance);
_instance->TemperatureSensor_TempSensorImpl_State = TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE;
{
_instance->TemperatureSensor_temp_var = f_TemperatureSensor_convertTemperature(_instance, value);
TemperatureSensor_send_TemperatureSensor_temperature_value(_instance, f_TemperatureSensor_convertTemperature(_instance, value));
}
TemperatureSensor_TempSensorImpl_OnEntry(TEMPERATURESENSOR_TEMPSENSORIMPL_RUNNING_STATE, _instance);
}
}
}

// Observers for outgoing messages:
void (*TemperatureSensor_send_TemperatureSensor_temperature_value_listener)(struct TemperatureSensor_Instance*, int16_t)= 0x0;
void register_TemperatureSensor_send_TemperatureSensor_temperature_value_listener(void (*_listener)(struct TemperatureSensor_Instance*, int16_t)){
TemperatureSensor_send_TemperatureSensor_temperature_value_listener = _listener;
}
void TemperatureSensor_send_TemperatureSensor_temperature_value(struct TemperatureSensor_Instance *_instance, int16_t val){
if (TemperatureSensor_send_TemperatureSensor_temperature_value_listener != 0x0) TemperatureSensor_send_TemperatureSensor_temperature_value_listener(_instance, val);
}
void (*TemperatureSensor_send_AnalogInput_read_analog_input_listener)(struct TemperatureSensor_Instance*)= 0x0;
void register_TemperatureSensor_send_AnalogInput_read_analog_input_listener(void (*_listener)(struct TemperatureSensor_Instance*)){
TemperatureSensor_send_AnalogInput_read_analog_input_listener = _listener;
}
void TemperatureSensor_send_AnalogInput_read_analog_input(struct TemperatureSensor_Instance *_instance){
if (TemperatureSensor_send_AnalogInput_read_analog_input_listener != 0x0) TemperatureSensor_send_AnalogInput_read_analog_input_listener(_instance);
}


/*****************************************************************************
 * Definitions for configuration : ArduinoNode
 *****************************************************************************/

#define MAX_INSTANCES 32
#define FIFO_SIZE 256

/*********************************
 * Instance IDs and lookup
 *********************************/

void * instances[MAX_INSTANCES];
uint16_t instances_count = 0;

void * instance_by_id(uint16_t id) {
  return instances[id];
}

uint16_t add_instance(void * instance_struct) {
  instances[instances_count] = instance_struct;
  return instances_count++;
}

/******************************************
 * Simple byte FIFO implementation
 ******************************************/

byte fifo[FIFO_SIZE];
int fifo_head = 0;
int fifo_tail = 0;

// Returns the number of byte currently in the fifo
int fifo_byte_length() {
  if (fifo_tail >= fifo_head)
    return fifo_tail - fifo_head;
  return fifo_tail + FIFO_SIZE - fifo_head;
}

// Returns the number of bytes currently available in the fifo
int fifo_byte_available() {
  return FIFO_SIZE - 1 - fifo_byte_length();
}

// Returns true if the fifo is empty
int fifo_empty() {
  return fifo_head == fifo_tail;
}

// Return true if the fifo is full
int fifo_full() {
  return fifo_head == ((fifo_tail + 1) % FIFO_SIZE);
}

// Enqueue 1 byte in the fifo if there is space
// returns 1 for sucess and 0 if the fifo was full
int fifo_enqueue(byte b) {
  int new_tail = (fifo_tail + 1) % FIFO_SIZE;
  if (new_tail == fifo_head) return 0; // the fifo is full
  fifo[fifo_tail] = b;
  fifo_tail = new_tail;
  return 1;
}

// Enqueue 1 byte in the fifo without checking for available space
// The caller should have checked that there is enough space
int _fifo_enqueue(byte b) {
  fifo[fifo_tail] = b;
  fifo_tail = (fifo_tail + 1) % FIFO_SIZE;
}

// Dequeue 1 byte in the fifo.
// The caller should check that the fifo is not empty
byte fifo_dequeue() {
  if (!fifo_empty()) {
    byte result = fifo[fifo_head];
    fifo_head = (fifo_head + 1) % FIFO_SIZE;
    return result;
  }
  return 0;
}

/*
void _fifo_enqueue_ptr(void * ptr) {
  int i;
  ptr_union_t proxy;
  proxy.pointer = ptr;
  for (i = 0; i<PTR_MAX_SIZE; i++) _fifo_enqueue(proxy.buffer[i]);
}

void * _fifo_dequeue_ptr() {
  int i;
  ptr_union_t proxy;
  for (i = 0; i<PTR_MAX_SIZE; i++) proxy.buffer[i] = _fifo_dequeue();
  return proxy.pointer;
}
*/
//Declaration of instance variables
struct MessageDeserializer_Instance ArduinoNode_deserializer_var;
struct AnalogInputArduino_Instance ArduinoNode_light_sensor_io_analog_input_var;
struct AnalogInputArduino_Instance ArduinoNode_temp_sensor_io_analog_input_var;
struct ArduinoArduino_Instance ArduinoNode_light_sensor_io_arduino_var;
struct TimerArduino_Instance ArduinoNode_light_sensor_io_timer_var;
struct OnChangeAnalogInput_Instance ArduinoNode_light_sensor_io_change_analog_input_var;
struct MessageSerializer_Instance ArduinoNode_serializer_var;
struct SensorsDisplay_Instance ArduinoNode_app_var;
struct LightSensor_Instance ArduinoNode_light_sensor_light_sensor_var;
struct ArduinoArduino_Instance ArduinoNode_temp_sensor_io_arduino_var;
struct TimerArduino_Instance ArduinoNode_temp_sensor_io_timer_var;
struct OnChangeAnalogInput_Instance ArduinoNode_temp_sensor_io_change_analog_input_var;
struct SerialArduino_Instance network_var;
struct TemperatureSensor_Instance ArduinoNode_temp_sensor_temperature_sensor_var;

// Enqueue of messages MessageDeserializer::RemoteControl::changeDisplay
void enqueue_MessageDeserializer_send_RemoteControl_changeDisplay(struct MessageDeserializer_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (1 >> 8) & 0xFF );
_fifo_enqueue( 1 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages AnalogInputArduino::AnalogIO::analog_read
void enqueue_AnalogInputArduino_send_AnalogIO_analog_read(struct AnalogInputArduino_Instance *_instance, uint8_t pin){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (2 >> 8) & 0xFF );
_fifo_enqueue( 2 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);
}
}
// Enqueue of messages AnalogInputArduino::AnalogInput::analog_input_value
void enqueue_AnalogInputArduino_send_AnalogInput_analog_input_value(struct AnalogInputArduino_Instance *_instance, int16_t value){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (3 >> 8) & 0xFF );
_fifo_enqueue( 3 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter value
_fifo_enqueue((value>>8) & 0xFF);
_fifo_enqueue(value & 0xFF);
}
}
// Enqueue of messages ArduinoArduino::AnalogIO::analog_read_result
void enqueue_ArduinoArduino_send_AnalogIO_analog_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, int16_t value){
if ( fifo_byte_available() > 7 ) {

_fifo_enqueue( (4 >> 8) & 0xFF );
_fifo_enqueue( 4 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter pin
_fifo_enqueue(pin & 0xFF);

// parameter value
_fifo_enqueue((value>>8) & 0xFF);
_fifo_enqueue(value & 0xFF);
}
}
// Enqueue of messages TimerArduino::timer::timer_timeout
void enqueue_TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (5 >> 8) & 0xFF );
_fifo_enqueue( 5 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages OnChangeAnalogInput::Timer::timer_start
void enqueue_OnChangeAnalogInput_send_Timer_timer_start(struct OnChangeAnalogInput_Instance *_instance, int delay){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (6 >> 8) & 0xFF );
_fifo_enqueue( 6 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter delay
_fifo_enqueue((delay>>8) & 0xFF);
_fifo_enqueue(delay & 0xFF);
}
}
// Enqueue of messages OnChangeAnalogInput::AnalogInput::read_analog_input
void enqueue_OnChangeAnalogInput_send_AnalogInput_read_analog_input(struct OnChangeAnalogInput_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (7 >> 8) & 0xFF );
_fifo_enqueue( 7 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages MessageSerializer::serial::serial_tx
void enqueue_MessageSerializer_send_serial_serial_tx(struct MessageSerializer_Instance *_instance, uint8_t b){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (8 >> 8) & 0xFF );
_fifo_enqueue( 8 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter b
_fifo_enqueue(b & 0xFF);
}
}
// Enqueue of messages SensorsDisplay::TemperatureSensor::read_temperature
void enqueue_SensorsDisplay_send_TemperatureSensor_read_temperature(struct SensorsDisplay_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (9 >> 8) & 0xFF );
_fifo_enqueue( 9 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages SensorsDisplay::LightSensor::read_light
void enqueue_SensorsDisplay_send_LightSensor_read_light(struct SensorsDisplay_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (10 >> 8) & 0xFF );
_fifo_enqueue( 10 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages LightSensor::LightSensor::light_value
void enqueue_LightSensor_send_LightSensor_light_value(struct LightSensor_Instance *_instance, uint16_t val){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (11 >> 8) & 0xFF );
_fifo_enqueue( 11 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter val
_fifo_enqueue((val>>8) & 0xFF);
_fifo_enqueue(val & 0xFF);
}
}
// Enqueue of messages LightSensor::AnalogInput::read_analog_input
void enqueue_LightSensor_send_AnalogInput_read_analog_input(struct LightSensor_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (12 >> 8) & 0xFF );
_fifo_enqueue( 12 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}
// Enqueue of messages SerialArduino::serial::serial_rx
void enqueue_SerialArduino_send_serial_serial_rx(struct SerialArduino_Instance *_instance, uint8_t b){
if ( fifo_byte_available() > 5 ) {

_fifo_enqueue( (13 >> 8) & 0xFF );
_fifo_enqueue( 13 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter b
_fifo_enqueue(b & 0xFF);
}
}
// Enqueue of messages TemperatureSensor::TemperatureSensor::temperature_value
void enqueue_TemperatureSensor_send_TemperatureSensor_temperature_value(struct TemperatureSensor_Instance *_instance, int16_t val){
if ( fifo_byte_available() > 6 ) {

_fifo_enqueue( (14 >> 8) & 0xFF );
_fifo_enqueue( 14 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );

// parameter val
_fifo_enqueue((val>>8) & 0xFF);
_fifo_enqueue(val & 0xFF);
}
}
// Enqueue of messages TemperatureSensor::AnalogInput::read_analog_input
void enqueue_TemperatureSensor_send_AnalogInput_read_analog_input(struct TemperatureSensor_Instance *_instance){
if ( fifo_byte_available() > 4 ) {

_fifo_enqueue( (15 >> 8) & 0xFF );
_fifo_enqueue( 15 & 0xFF );

// ID of the source instance
_fifo_enqueue( (_instance->id >> 8) & 0xFF );
_fifo_enqueue( _instance->id & 0xFF );
}
}

// Dispatch for messages MessageDeserializer::RemoteControl::changeDisplay
void dispatch_MessageDeserializer_send_RemoteControl_changeDisplay(struct MessageDeserializer_Instance *_instance){
if (_instance == &ArduinoNode_deserializer_var) {
SensorsDisplay_handle_RemoteControl_changeDisplay(&ArduinoNode_app_var);
}
}
// Dispatch for messages AnalogInputArduino::AnalogIO::analog_read
void dispatch_AnalogInputArduino_send_AnalogIO_analog_read(struct AnalogInputArduino_Instance *_instance, uint8_t pin){
if (_instance == &ArduinoNode_temp_sensor_io_analog_input_var) {
ArduinoArduino_handle_AnalogIO_analog_read(&ArduinoNode_temp_sensor_io_arduino_var, pin);
}
if (_instance == &ArduinoNode_light_sensor_io_analog_input_var) {
ArduinoArduino_handle_AnalogIO_analog_read(&ArduinoNode_light_sensor_io_arduino_var, pin);
}
}
// Dispatch for messages AnalogInputArduino::AnalogInput::analog_input_value
void dispatch_AnalogInputArduino_send_AnalogInput_analog_input_value(struct AnalogInputArduino_Instance *_instance, int16_t value){
if (_instance == &ArduinoNode_temp_sensor_io_analog_input_var) {
OnChangeAnalogInput_handle_AnalogInput_analog_input_value(&ArduinoNode_temp_sensor_io_change_analog_input_var, value);
TemperatureSensor_handle_AnalogInput_analog_input_value(&ArduinoNode_temp_sensor_temperature_sensor_var, value);
}
if (_instance == &ArduinoNode_light_sensor_io_analog_input_var) {
OnChangeAnalogInput_handle_AnalogInput_analog_input_value(&ArduinoNode_light_sensor_io_change_analog_input_var, value);
LightSensor_handle_AnalogInput_analog_input_value(&ArduinoNode_light_sensor_light_sensor_var, value);
}
}
// Dispatch for messages ArduinoArduino::AnalogIO::analog_read_result
void dispatch_ArduinoArduino_send_AnalogIO_analog_read_result(struct ArduinoArduino_Instance *_instance, uint8_t pin, int16_t value){
if (_instance == &ArduinoNode_light_sensor_io_arduino_var) {
AnalogInputArduino_handle_AnalogIO_analog_read_result(&ArduinoNode_light_sensor_io_analog_input_var, pin, value);
}
if (_instance == &ArduinoNode_temp_sensor_io_arduino_var) {
AnalogInputArduino_handle_AnalogIO_analog_read_result(&ArduinoNode_temp_sensor_io_analog_input_var, pin, value);
}
}
// Dispatch for messages TimerArduino::timer::timer_timeout
void dispatch_TimerArduino_send_timer_timer_timeout(struct TimerArduino_Instance *_instance){
if (_instance == &ArduinoNode_temp_sensor_io_timer_var) {
OnChangeAnalogInput_handle_Timer_timer_timeout(&ArduinoNode_temp_sensor_io_change_analog_input_var);
}
if (_instance == &ArduinoNode_light_sensor_io_timer_var) {
OnChangeAnalogInput_handle_Timer_timer_timeout(&ArduinoNode_light_sensor_io_change_analog_input_var);
}
}
// Dispatch for messages OnChangeAnalogInput::Timer::timer_start
void dispatch_OnChangeAnalogInput_send_Timer_timer_start(struct OnChangeAnalogInput_Instance *_instance, int delay){
if (_instance == &ArduinoNode_temp_sensor_io_change_analog_input_var) {
TimerArduino_handle_timer_timer_start(&ArduinoNode_temp_sensor_io_timer_var, delay);
}
if (_instance == &ArduinoNode_light_sensor_io_change_analog_input_var) {
TimerArduino_handle_timer_timer_start(&ArduinoNode_light_sensor_io_timer_var, delay);
}
}
// Dispatch for messages OnChangeAnalogInput::AnalogInput::read_analog_input
void dispatch_OnChangeAnalogInput_send_AnalogInput_read_analog_input(struct OnChangeAnalogInput_Instance *_instance){
if (_instance == &ArduinoNode_temp_sensor_io_change_analog_input_var) {
AnalogInputArduino_handle_AnalogInput_read_analog_input(&ArduinoNode_temp_sensor_io_analog_input_var);
}
if (_instance == &ArduinoNode_light_sensor_io_change_analog_input_var) {
AnalogInputArduino_handle_AnalogInput_read_analog_input(&ArduinoNode_light_sensor_io_analog_input_var);
}
}
// Dispatch for messages MessageSerializer::serial::serial_tx
void dispatch_MessageSerializer_send_serial_serial_tx(struct MessageSerializer_Instance *_instance, uint8_t b){
if (_instance == &ArduinoNode_serializer_var) {
SerialArduino_handle_serial_serial_tx(&network_var, b);
}
}
// Dispatch for messages SensorsDisplay::RemoteControl::temperature
void dispatch_SensorsDisplay_send_RemoteControl_temperature(struct SensorsDisplay_Instance *_instance, uint16_t temp){
if (_instance == &ArduinoNode_app_var) {
MessageSerializer_handle_RemoteControl_temperature(&ArduinoNode_serializer_var, temp);
}
}
// Dispatch for messages SensorsDisplay::RemoteControl::light
void dispatch_SensorsDisplay_send_RemoteControl_light(struct SensorsDisplay_Instance *_instance, uint16_t light){
if (_instance == &ArduinoNode_app_var) {
MessageSerializer_handle_RemoteControl_light(&ArduinoNode_serializer_var, light);
}
}
// Dispatch for messages SensorsDisplay::TemperatureSensor::read_temperature
void dispatch_SensorsDisplay_send_TemperatureSensor_read_temperature(struct SensorsDisplay_Instance *_instance){
if (_instance == &ArduinoNode_app_var) {
TemperatureSensor_handle_TemperatureSensor_read_temperature(&ArduinoNode_temp_sensor_temperature_sensor_var);
}
}
// Dispatch for messages SensorsDisplay::LightSensor::read_light
void dispatch_SensorsDisplay_send_LightSensor_read_light(struct SensorsDisplay_Instance *_instance){
if (_instance == &ArduinoNode_app_var) {
LightSensor_handle_LightSensor_read_light(&ArduinoNode_light_sensor_light_sensor_var);
}
}
// Dispatch for messages LightSensor::LightSensor::light_value
void dispatch_LightSensor_send_LightSensor_light_value(struct LightSensor_Instance *_instance, uint16_t val){
if (_instance == &ArduinoNode_light_sensor_light_sensor_var) {
SensorsDisplay_handle_LightSensor_light_value(&ArduinoNode_app_var, val);
}
}
// Dispatch for messages LightSensor::AnalogInput::read_analog_input
void dispatch_LightSensor_send_AnalogInput_read_analog_input(struct LightSensor_Instance *_instance){
if (_instance == &ArduinoNode_light_sensor_light_sensor_var) {
AnalogInputArduino_handle_AnalogInput_read_analog_input(&ArduinoNode_light_sensor_io_analog_input_var);
}
}
// Dispatch for messages SerialArduino::serial::serial_rx
void dispatch_SerialArduino_send_serial_serial_rx(struct SerialArduino_Instance *_instance, uint8_t b){
if (_instance == &network_var) {
MessageDeserializer_handle_serial_serial_rx(&ArduinoNode_deserializer_var, b);
}
}
// Dispatch for messages TemperatureSensor::TemperatureSensor::temperature_value
void dispatch_TemperatureSensor_send_TemperatureSensor_temperature_value(struct TemperatureSensor_Instance *_instance, int16_t val){
if (_instance == &ArduinoNode_temp_sensor_temperature_sensor_var) {
SensorsDisplay_handle_TemperatureSensor_temperature_value(&ArduinoNode_app_var, val);
}
}
// Dispatch for messages TemperatureSensor::AnalogInput::read_analog_input
void dispatch_TemperatureSensor_send_AnalogInput_read_analog_input(struct TemperatureSensor_Instance *_instance){
if (_instance == &ArduinoNode_temp_sensor_temperature_sensor_var) {
AnalogInputArduino_handle_AnalogInput_read_analog_input(&ArduinoNode_temp_sensor_io_analog_input_var);
}
}

void processMessageQueue() {
if (fifo_empty()) return; // return if there is nothing to do

byte mbuf[5];
uint8_t mbufi = 0;

// Read the code of the next port/message in the queue
uint16_t code = fifo_dequeue() << 8;

code += fifo_dequeue();

// Switch to call the appropriate handler
switch(code) {
case 1:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_MessageDeserializer_send_RemoteControl_changeDisplay((struct MessageDeserializer_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 2:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_AnalogInputArduino_send_AnalogIO_analog_read((struct AnalogInputArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ );
break;
case 3:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_AnalogInputArduino_send_AnalogInput_analog_input_value((struct AnalogInputArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
(mbuf[2]<<8) + mbuf[3] /* value */ );
break;
case 4:
while (mbufi < 5) mbuf[mbufi++] = fifo_dequeue();
dispatch_ArduinoArduino_send_AnalogIO_analog_read_result((struct ArduinoArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* pin */ ,
(mbuf[3]<<8) + mbuf[4] /* value */ );
break;
case 5:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_TimerArduino_send_timer_timer_timeout((struct TimerArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 6:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_OnChangeAnalogInput_send_Timer_timer_start((struct OnChangeAnalogInput_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
(mbuf[2]<<8) + mbuf[3] /* delay */ );
break;
case 7:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_OnChangeAnalogInput_send_AnalogInput_read_analog_input((struct OnChangeAnalogInput_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 8:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_MessageSerializer_send_serial_serial_tx((struct MessageSerializer_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* b */ );
break;
case 9:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_SensorsDisplay_send_TemperatureSensor_read_temperature((struct SensorsDisplay_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 10:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_SensorsDisplay_send_LightSensor_read_light((struct SensorsDisplay_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 11:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_LightSensor_send_LightSensor_light_value((struct LightSensor_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
(mbuf[2]<<8) + mbuf[3] /* val */ );
break;
case 12:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_LightSensor_send_AnalogInput_read_analog_input((struct LightSensor_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
case 13:
while (mbufi < 3) mbuf[mbufi++] = fifo_dequeue();
dispatch_SerialArduino_send_serial_serial_rx((struct SerialArduino_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
mbuf[2] /* b */ );
break;
case 14:
while (mbufi < 4) mbuf[mbufi++] = fifo_dequeue();
dispatch_TemperatureSensor_send_TemperatureSensor_temperature_value((struct TemperatureSensor_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */,
(mbuf[2]<<8) + mbuf[3] /* val */ );
break;
case 15:
while (mbufi < 2) mbuf[mbufi++] = fifo_dequeue();
dispatch_TemperatureSensor_send_AnalogInput_read_analog_input((struct TemperatureSensor_Instance*)instance_by_id((mbuf[0] << 8) + mbuf[1]) /* instance */);
break;
}
}

void initialize_configuration_ArduinoNode() {
// Initialize connectors
register_MessageDeserializer_send_RemoteControl_changeDisplay_listener(enqueue_MessageDeserializer_send_RemoteControl_changeDisplay);
register_AnalogInputArduino_send_AnalogIO_analog_read_listener(enqueue_AnalogInputArduino_send_AnalogIO_analog_read);
register_AnalogInputArduino_send_AnalogInput_analog_input_value_listener(enqueue_AnalogInputArduino_send_AnalogInput_analog_input_value);
register_ArduinoArduino_send_AnalogIO_analog_read_result_listener(enqueue_ArduinoArduino_send_AnalogIO_analog_read_result);
register_TimerArduino_send_timer_timer_timeout_listener(enqueue_TimerArduino_send_timer_timer_timeout);
register_OnChangeAnalogInput_send_Timer_timer_start_listener(enqueue_OnChangeAnalogInput_send_Timer_timer_start);
register_OnChangeAnalogInput_send_AnalogInput_read_analog_input_listener(enqueue_OnChangeAnalogInput_send_AnalogInput_read_analog_input);
register_MessageSerializer_send_serial_serial_tx_listener(enqueue_MessageSerializer_send_serial_serial_tx);
register_SensorsDisplay_send_RemoteControl_temperature_listener(dispatch_SensorsDisplay_send_RemoteControl_temperature);
register_SensorsDisplay_send_RemoteControl_light_listener(dispatch_SensorsDisplay_send_RemoteControl_light);
register_SensorsDisplay_send_TemperatureSensor_read_temperature_listener(enqueue_SensorsDisplay_send_TemperatureSensor_read_temperature);
register_SensorsDisplay_send_LightSensor_read_light_listener(enqueue_SensorsDisplay_send_LightSensor_read_light);
register_LightSensor_send_LightSensor_light_value_listener(enqueue_LightSensor_send_LightSensor_light_value);
register_LightSensor_send_AnalogInput_read_analog_input_listener(enqueue_LightSensor_send_AnalogInput_read_analog_input);
register_SerialArduino_send_serial_serial_rx_listener(enqueue_SerialArduino_send_serial_serial_rx);
register_TemperatureSensor_send_TemperatureSensor_temperature_value_listener(enqueue_TemperatureSensor_send_TemperatureSensor_temperature_value);
register_TemperatureSensor_send_AnalogInput_read_analog_input_listener(enqueue_TemperatureSensor_send_AnalogInput_read_analog_input);

// Init the ID, state variables and properties for instance ArduinoNode_deserializer
ArduinoNode_deserializer_var.id = add_instance( (void*) &ArduinoNode_deserializer_var);
ArduinoNode_deserializer_var.MessageDeserializer_receive_State = MESSAGEDESERIALIZER_RECEIVE_IDLE_STATE;
ArduinoNode_deserializer_var.PacketManager_lengthInteger_var = 2;
ArduinoNode_deserializer_var.PacketManager_lengthString_var = 8;
ArduinoNode_deserializer_var.PacketManager_lengthUInt16_var = 2;
ArduinoNode_deserializer_var.PacketManager_MAX_PACKET_SIZE_var = 16;
ArduinoNode_deserializer_var.PacketManager_START_BYTE_var = 0x7F;
ArduinoNode_deserializer_var.PacketManager_STOP_BYTE_var = 0x7E;
ArduinoNode_deserializer_var.PacketManager_ESCAPE_BYTE_var = 0x7D;
ArduinoNode_deserializer_var.PacketManager_CODE_POSITION_var = 3;
ArduinoNode_deserializer_var.PacketManager_LENGTH_POSITION_var = 4;
ArduinoNode_deserializer_var.PacketManager_DATA_POSITION_var = 5;
ArduinoNode_deserializer_var.PacketManager_index_var = 0;

// Init the ID, state variables and properties for instance ArduinoNode_light_sensor_io_analog_input
ArduinoNode_light_sensor_io_analog_input_var.id = add_instance( (void*) &ArduinoNode_light_sensor_io_analog_input_var);
ArduinoNode_light_sensor_io_analog_input_var.AnalogInputArduino_SimpleAnalogInputImp_State = ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE;
ArduinoNode_light_sensor_io_analog_input_var.AnalogInputArduino_pin_var = ANALOGPIN_A_1;

// Init the ID, state variables and properties for instance ArduinoNode_temp_sensor_io_analog_input
ArduinoNode_temp_sensor_io_analog_input_var.id = add_instance( (void*) &ArduinoNode_temp_sensor_io_analog_input_var);
ArduinoNode_temp_sensor_io_analog_input_var.AnalogInputArduino_SimpleAnalogInputImp_State = ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_RUNNING_STATE;
ArduinoNode_temp_sensor_io_analog_input_var.AnalogInputArduino_pin_var = ANALOGPIN_A_3;

// Init the ID, state variables and properties for instance ArduinoNode_light_sensor_io_arduino
ArduinoNode_light_sensor_io_arduino_var.id = add_instance( (void*) &ArduinoNode_light_sensor_io_arduino_var);
ArduinoNode_light_sensor_io_arduino_var.ArduinoArduino_ArduinoArduino_State = ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE;

// Init the ID, state variables and properties for instance ArduinoNode_light_sensor_io_timer
ArduinoNode_light_sensor_io_timer_var.id = add_instance( (void*) &ArduinoNode_light_sensor_io_timer_var);
ArduinoNode_light_sensor_io_timer_var.TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
ArduinoNode_light_sensor_io_timer_var.TimerArduino_SoftTimer_target_var = 0;

// Init the ID, state variables and properties for instance ArduinoNode_light_sensor_io_change_analog_input
ArduinoNode_light_sensor_io_change_analog_input_var.id = add_instance( (void*) &ArduinoNode_light_sensor_io_change_analog_input_var);
ArduinoNode_light_sensor_io_change_analog_input_var.OnChangeAnalogInput_OnChangeAnalogInputImpl_State = ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE;
ArduinoNode_light_sensor_io_change_analog_input_var.OnChangeAnalogInput_refresh_rate_var = 500;
ArduinoNode_light_sensor_io_change_analog_input_var.OnChangeAnalogInput_OnChangeAnalogInputImpl_oldValue_var =  -1;

// Init the ID, state variables and properties for instance ArduinoNode_serializer
ArduinoNode_serializer_var.id = add_instance( (void*) &ArduinoNode_serializer_var);
ArduinoNode_serializer_var.MessageSerializer_SerializerBehavior_State = MESSAGESERIALIZER_SERIALIZERBEHAVIOR_SERIALIZE_STATE;
ArduinoNode_serializer_var.PacketManager_lengthInteger_var = 2;
ArduinoNode_serializer_var.PacketManager_lengthString_var = 8;
ArduinoNode_serializer_var.PacketManager_lengthUInt16_var = 2;
ArduinoNode_serializer_var.PacketManager_MAX_PACKET_SIZE_var = 16;
ArduinoNode_serializer_var.PacketManager_START_BYTE_var = 0x7F;
ArduinoNode_serializer_var.PacketManager_STOP_BYTE_var = 0x7E;
ArduinoNode_serializer_var.PacketManager_ESCAPE_BYTE_var = 0x7D;
ArduinoNode_serializer_var.PacketManager_CODE_POSITION_var = 3;
ArduinoNode_serializer_var.PacketManager_LENGTH_POSITION_var = 4;
ArduinoNode_serializer_var.PacketManager_DATA_POSITION_var = 5;
ArduinoNode_serializer_var.PacketManager_index_var = 0;

// Init the ID, state variables and properties for instance ArduinoNode_app
ArduinoNode_app_var.id = add_instance( (void*) &ArduinoNode_app_var);
ArduinoNode_app_var.SensorsDisplay_SensorsDisplayImpl_State = SENSORSDISPLAY_SENSORSDISPLAYIMPL_TEMP_STATE;
ArduinoNode_app_var.SensorsDisplay_tempDisplay_var = 0;
ArduinoNode_app_var.SensorsDisplay_lightDisplay_var = 2;
ArduinoNode_app_var.SensorsDisplay_period_var = 2000;

// Init the ID, state variables and properties for instance ArduinoNode_light_sensor_light_sensor
ArduinoNode_light_sensor_light_sensor_var.id = add_instance( (void*) &ArduinoNode_light_sensor_light_sensor_var);
ArduinoNode_light_sensor_light_sensor_var.LightSensor_LightSensorImpl_State = LIGHTSENSOR_LIGHTSENSORIMPL_RUNNING_STATE;

// Init the ID, state variables and properties for instance ArduinoNode_temp_sensor_io_arduino
ArduinoNode_temp_sensor_io_arduino_var.id = add_instance( (void*) &ArduinoNode_temp_sensor_io_arduino_var);
ArduinoNode_temp_sensor_io_arduino_var.ArduinoArduino_ArduinoArduino_State = ARDUINOARDUINO_ARDUINOARDUINO_RUNNINGARDUINO_STATE;

// Init the ID, state variables and properties for instance ArduinoNode_temp_sensor_io_timer
ArduinoNode_temp_sensor_io_timer_var.id = add_instance( (void*) &ArduinoNode_temp_sensor_io_timer_var);
ArduinoNode_temp_sensor_io_timer_var.TimerArduino_SoftTimer_State = TIMERARDUINO_SOFTTIMER_IDLE_STATE;
ArduinoNode_temp_sensor_io_timer_var.TimerArduino_SoftTimer_target_var = 0;

// Init the ID, state variables and properties for instance ArduinoNode_temp_sensor_io_change_analog_input
ArduinoNode_temp_sensor_io_change_analog_input_var.id = add_instance( (void*) &ArduinoNode_temp_sensor_io_change_analog_input_var);
ArduinoNode_temp_sensor_io_change_analog_input_var.OnChangeAnalogInput_OnChangeAnalogInputImpl_State = ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_RUNNING_STATE;
ArduinoNode_temp_sensor_io_change_analog_input_var.OnChangeAnalogInput_refresh_rate_var = 500;
ArduinoNode_temp_sensor_io_change_analog_input_var.OnChangeAnalogInput_OnChangeAnalogInputImpl_oldValue_var =  -1;

// Init the ID, state variables and properties for instance network
network_var.id = add_instance( (void*) &network_var);
network_var.SerialArduino_SerialImpl_State = SERIALARDUINO_SERIALIMPL_RECEIVING_STATE;

// Init the ID, state variables and properties for instance ArduinoNode_temp_sensor_temperature_sensor
ArduinoNode_temp_sensor_temperature_sensor_var.id = add_instance( (void*) &ArduinoNode_temp_sensor_temperature_sensor_var);
ArduinoNode_temp_sensor_temperature_sensor_var.TemperatureSensor_TempSensorImpl_State = TEMPERATURESENSOR_TEMPSENSORIMPL_READ_STATE;
ArduinoNode_temp_sensor_temperature_sensor_var.TemperatureSensor_temp_var = 0;

MessageDeserializer_receive_OnEntry(MESSAGEDESERIALIZER_RECEIVE_STATE, &ArduinoNode_deserializer_var);
AnalogInputArduino_SimpleAnalogInputImp_OnEntry(ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_STATE, &ArduinoNode_light_sensor_io_analog_input_var);
AnalogInputArduino_SimpleAnalogInputImp_OnEntry(ANALOGINPUTARDUINO_SIMPLEANALOGINPUTIMP_STATE, &ArduinoNode_temp_sensor_io_analog_input_var);
ArduinoArduino_ArduinoArduino_OnEntry(ARDUINOARDUINO_ARDUINOARDUINO_STATE, &ArduinoNode_light_sensor_io_arduino_var);
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_STATE, &ArduinoNode_light_sensor_io_timer_var);
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_STATE, &ArduinoNode_light_sensor_io_change_analog_input_var);
MessageSerializer_SerializerBehavior_OnEntry(MESSAGESERIALIZER_SERIALIZERBEHAVIOR_STATE, &ArduinoNode_serializer_var);
SensorsDisplay_SensorsDisplayImpl_OnEntry(SENSORSDISPLAY_SENSORSDISPLAYIMPL_STATE, &ArduinoNode_app_var);
LightSensor_LightSensorImpl_OnEntry(LIGHTSENSOR_LIGHTSENSORIMPL_STATE, &ArduinoNode_light_sensor_light_sensor_var);
ArduinoArduino_ArduinoArduino_OnEntry(ARDUINOARDUINO_ARDUINOARDUINO_STATE, &ArduinoNode_temp_sensor_io_arduino_var);
TimerArduino_SoftTimer_OnEntry(TIMERARDUINO_SOFTTIMER_STATE, &ArduinoNode_temp_sensor_io_timer_var);
OnChangeAnalogInput_OnChangeAnalogInputImpl_OnEntry(ONCHANGEANALOGINPUT_ONCHANGEANALOGINPUTIMPL_STATE, &ArduinoNode_temp_sensor_io_change_analog_input_var);
SerialArduino_SerialImpl_OnEntry(SERIALARDUINO_SERIALIMPL_STATE, &network_var);
TemperatureSensor_TempSensorImpl_OnEntry(TEMPERATURESENSOR_TEMPSENSORIMPL_STATE, &ArduinoNode_temp_sensor_temperature_sensor_var);
}

/*****************************************************************************
 * Main for configuration : ArduinoNode
 *****************************************************************************/

void setup() {
initialize_configuration_ArduinoNode();

}

void loop() {
TimerArduino_handle_Polling_poll(&ArduinoNode_light_sensor_io_timer_var);
TimerArduino_handle_Polling_poll(&ArduinoNode_temp_sensor_io_timer_var);
SerialArduino_handle_Polling_poll(&network_var);

processMessageQueue();
}