import "../../../core/serializer.thingml"
import "../../../core/timer.thingml"
import "../../../core/_arduino/serializer.thingml"
import "../../../core/_linux/LinuxSerial.thingml"
import "../../../core/_linux/LinuxDB.thingml"
import "../../../core/_linux/LinuxSensapp.thingml"
import "../../../core/_linux/LinuxClock.thingml"

import "../weatherAPI.thingml"


thing fragment StartMsg {
    message start();    
}

thing WeatherStation includes RemoteMonitoringMsgs, StartMsg, TimerClient, DBClient
{
    property counter : Integer = 12//upload to sensapp every counter*delay seconds
    property delay: Integer = 5//when update one sensor every 5 seconds
    property i : Integer = 0
    
    provided port Start 
    {
        receives start    
    }
    
    provided port RemoteControlIn 
    {
        receives temperature, light    
    }
    
    provided port RemoteControlOut
    {
        sends changeDisplay
    }
    
    statechart SensorsDisplayImpl init Init
   	{
       
       state Init {
         on entry do
           print("Waiting...\n")
         end
         
         on exit do
           print("Processing...\n")
         end
         
         transition -> InitDB 
         event t : Start?start
       }
       
       state InitDB {
           on entry do
             print("Starting DB...\n")
             db!db_init()
           end
           
           on exit do
            print("done!\n")
           end
           
           transition -> Process
           event t : db?db_init_done
       }
   		
       state Process {
           
         on entry do
           timer!timer_start(delay)
           i = i + 1
         end
           
        internal event t : RemoteControlIn?temperature
        action do
            print("Temperature is: ")
            'printf("%u", ' & t.temp & ');'
            print("\n")
            db!push_int("weather", "temp", t.temp)
        end
        
        internal event l : RemoteControlIn?light
        action do
            print("Light is: ")
            'printf("%u", ' & l.light & ');'
            print("\n")
            db!push_int("weather", "light", l.light)
        end
        
        transition -> Process 
        event t : timer?timer_timeout
        action do
            print("Changing Display on Arduino\n")
            RemoteControlOut!changeDisplay()
            if (i > counter) do
                i = 0
                db!db_upload("weather", "temp")
                db!db_upload("weather", "light")
            end
        end            
       }
        
    }
   
}





//Generated by ThingML
thing MessageSerializer includes SerializerArduino, RemoteMonitoringMsgs {
required port RemoteControl{
receives changeDisplay
}

statechart SerializerBehavior init Serialize {
state Serialize{
internal event m : RemoteControl?changeDisplay action
do
setHeader(20, 0)
send()
end

}
}

}

thing MessageDeserializer includes DeserializerArduino, RemoteMonitoringMsgs {
required port RemoteControl{
sends temperature, light
}

function forward() do
index = DATA_POSITION
readonly var code : Byte = buffer[CODE_POSITION]
if (code == 10) do
deserializeRemote_temperature()
end
if (code == 11) do
deserializeRemote_light()
end
end

function deserializeRemote_temperature()
do
readonly var t : UInt16 = deserializeUInt16()
RemoteControl!temperature(t)
end

function deserializeRemote_light()
do
readonly var t : UInt16 = deserializeUInt16()
RemoteControl!light(t)
end

statechart receive init Idle {
    state Idle {
        on entry index = 0
        
        transition -> ReceiveMessage event m : serial?serial_rx
        guard m.b == START_BYTE
    }

    state ReceiveMessage {
        transition -> Escape event m : serial?serial_rx
        guard m.b == ESCAPE_BYTE

        internal event m : serial?serial_rx
        guard not (m.b == ESCAPE_BYTE or m.b == STOP_BYTE or m.b == START_BYTE)
        action do
            storeByte(m.b)
        end

        transition -> Idle event m : serial?serial_rx
        guard m.b == STOP_BYTE
        action do
            forward()
        end

        internal event m : serial?serial_rx
        guard m.b == START_BYTE // Should not happen with a reliable channel
        action do
            index = 0 // Reset if it happens (some bytes have been lost at some point)
        end
    }

    state Escape {
        transition receive -> ReceiveMessage
        event m : serial?serial_rx
        action storeByte(m.b)
    }
}

}

//END Generated by ThingML


thing SerialProxy includes SerialMsgs, StartMsg
{
    readonly property serialPort : String = "/dev/ttyACM0"
    
    required port Start 
    {
        sends start    
    }
    
    required port serial {
        sends serial_open, serial_tx
        receives serial_opened, serial_rx    
    }

	provided port deserializer {
		sends serial_rx
	}

	provided port serializer {
		receives serial_tx
	}

    statechart SensorsDisplayImpl init Init
   	{
              
       state Init {
         on entry do
           serial!serial_open(serialPort, 9600)
         end
         
         transition -> Process 
         event t : serial?serial_opened
         action Start!start()
       }
   		
       state Process {
           
        internal event rx : serial?serial_rx
        action do
            deserializer!serial_rx(rx.b)
        end
        
        internal event tx : serializer?serial_tx
        action do
            serial!serial_tx(tx.b)
        end    
       }
        
    }

}




configuration RaspiNode
@remote "app::.*::RemoteControl::.*"
@add_c_libraries "mongoc bson"
@add_c_directives "MONGO_HAVE_STDINT=1"
{
    instance app : WeatherStation
    instance proxy : SerialProxy
        
    instance deserializer : MessageDeserializer
    instance serializer : MessageSerializer
    instance serial : LinuxSerial
    
    instance db : LinuxDB
    connector app.db => db.db
    
    instance sensapp : LinuxSensapp
    connector db.sensapp => sensapp.sensapp
    
    // Clock needed by the timer
	instance c : LinuxClock 
	set c.period = 1000
	// Timer
	instance t : ClockTimer
	connector t.clock => c.signal
    connector app.timer => t.timer
	// Timer2
	instance t2 : ClockTimer
	connector t2.clock => c.signal
    connector db.timer => t2.timer
    
    connector deserializer.serial => proxy.deserializer
    connector deserializer.RemoteControl => app.RemoteControlIn
    connector serializer.serial => proxy.serializer
    connector serializer.RemoteControl => app.RemoteControlOut
    connector proxy.serial => serial.serial
    connector proxy.Start => app.Start
}